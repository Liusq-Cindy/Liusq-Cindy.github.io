> 总结答案要点，让回答更统一完整，每一个问题是一个大类体系，里面会包含多个深入的子问题

1. [从输入url到展示页面的过程？](https://www.notion.so/Test-http-c74ad1aa76c74f7d91c1bff8281b9699)
2. [浏览器缓存机制？](https://www.notion.so/Test-http-c74ad1aa76c74f7d91c1bff8281b9699)
3. [浏览器渲染机制？进程线程？](https://www.notion.so/Test-http-c74ad1aa76c74f7d91c1bff8281b9699)
4. [前端安全？](https://www.notion.so/Test-http-c74ad1aa76c74f7d91c1bff8281b9699)
5. [http协议的发展历程？](https://www.notion.so/Test-http-c74ad1aa76c74f7d91c1bff8281b9699)
6. [http请求？](https://www.notion.so/Test-http-c74ad1aa76c74f7d91c1bff8281b9699)
7. [浏览器存储？](https://www.notion.so/Test-http-c74ad1aa76c74f7d91c1bff8281b9699)
8. [同源策略和跨域？](https://www.notion.so/Test-http-c74ad1aa76c74f7d91c1bff8281b9699)
9. [关于websocket?](https://www.notion.so/Test-http-c74ad1aa76c74f7d91c1bff8281b9699)

# 1、从输入url到展示页面的过程？

[https://juejin.cn/post/6888875643266662414](https://juejin.cn/post/6888875643266662414)

### 阐述下这个过程：

输入url到页面展示，是个很复杂的过程，从前端层面上来说，大致是这样的过程：

（地址栏判断—本地缓存查地址—dns解析—TCP三次握手—期间通过强制缓存、协商缓存控制数据的返回—获取index.html文件—加载资源如js脚本等—-解析dom树、css树、重排重绘、渲染页面—-执行js上下文—-页面展示——等待交互）

1. 输入url后，浏览器主进程接管，解析url，判断是地址还是关键词搜索
2. 检查浏览器是否有请求该utl的ip缓存，有缓存就不用dns解析，会返回对应的ip
3. dns解析，查询对应的ip地址
4. 浏览器开辟一个网络请求线程，经历五层因特网协议栈，三次握手建立TCP连接，如果要断开时，要经历4次挥手
5. 建立TCP连接后，向服务端发送http请求

    [HTTP协议知识点汇总](https://www.notion.so/HTTP-65cbca00bb7f47229a67d8640e8dd31d)

6. 期间会根据http的强制缓存和协商缓存处理数据的返回

    强制缓存**Cache-Control**：（浏览器）存在缓存结果且http报文有对应的请求头

    协商缓存：(服务端)强制缓存失效时，通过资源是否更新，请求头和响应头的字段来判断 304 **Last-Modified / If-Modified-Since 以及 Etag / If-None-Match**

7. 服务端处理逻辑，http返回数据，如index.html文件。
8. 浏览器生成dom树、CSS树，合成render树，经过重排重绘的过程
9. 浏览器会将各层的信息发送给浏览器的GPU，GPU会将各层合成（composite），显示在屏幕上
10. 在解析html时，如果遇到一些资源连接如css样式资源、js脚本、图片，会单独开启一个下载进程去下载资源。如果是js脚本，会阻塞浏览器解析的。如果不希望阻塞，可加上async属性。
11. 由js引擎线程在对应的时间节点，执行我们相关的js脚本，如vue的一些生命周期，这里也涉及到了js的事件循环机制。
12. GUI线程渲染页面，展示到屏幕中。之后当用户发生交互时，继续由js引擎等各个线程处理。

### 三次握手和四次挥手的过程

> 在http1.0中往往一个资源下载就需要对应一个tcp/ip请求，2.0则可以并发

```jsx
// 三次握手建立tcp连接：
客户端：hello，你是server么？
服务端：hello，我是server，你是client么
客户端：yes，我是client
// 待需要断开时，四次挥手断开连接
主动方：我已经关闭了向你那边的主动通道了，只能被动接收了
被动方：收到通道关闭的信息
被动方：那我也告诉你，我这边向你的主动通道也关闭了
主动方：最后收到数据，之后双方无法通信
```

### 五层（七层）协议栈

> 五层因特网协议栈

1.应用层(dns,http) DNS解析成IP并发送http请求

2.传输层(tcp,udp) 建立tcp连接（三次握手）

3.网络层(IP,ARP) IP寻址

4.数据链路层(PPP) 封装成帧

5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）

当然，其实也有一个完整的OSI七层框架，与之相比，多了会话层、表示层。

OSI七层框架：`物理层`、`数据链路层`、`网络层`、`传输层`、`会话层`（处理对话）、`表示层`（加密）、`应用层`

# 2、浏览器缓存机制？

### 什么是浏览器缓存？

通常所说的浏览器缓存，其实就是浏览器保存通过HTTP获取的所有资源，是浏览器将网络资源存储在本地的一种行为，通常说的浏览器缓存指的都是http缓存。

### 那些资源被缓存

静态资源：js、css、图片，一般很少会改动，而html一般是不做缓存的

对js的文件，发现我们在webpack中会加一个hash值，也是为了当文件改变，hash值改变，生成一个新的文件，这样文件缓存就没有问题了

### 往返缓存

操作浏览器history对象或者前进后退按钮，会触发浏览器的往返缓存，这是浏览器的一种优化，BF Cache可能会把dom甚至js对象都会缓存。如果我们希望用户前进后退都重新请求页面的话，可以通过监听**pagehide/pageshow 事件，判断event对象的persisted属性，如果是true就是有缓存，否则是false。**

```jsx
window.onpageshow = function(event) { 
// 或window.addEventListener('pageshow',fn)
    if (event.persisted) {
        window.location.reload() 
    }
};
```

另外，**先是onload事件，从而才是pageshow事件。**

### http缓存—强制缓存、协商缓存

[https://segmentfault.com/a/1190000017962411](https://segmentfault.com/a/1190000017962411)

1、http请求，第一次请求后，服务端会将请求结果和控制缓存的字段返回给客户端，客户端会进行缓存处理。在第二次请求时，客户端会先尝试强制缓存，由请求头字段`cache-Control`控制，如果cache-Control有缓存，比如设置了max-age过期时间，并且能找到缓存资源，则强制缓存生效，否则触发协商缓存。

如private默认可缓存，no-cache协商缓存来定，no-store不缓存、max-age缓存失效时间

2、协商缓存由客户端和服务端一起控制，对应http请求和响应的一对头部字段（ `If-Modified-Since/ Last-Modified`）或者（`If-None-Match / Etag` ），如果这两个时间点对上或etag没有更新，会触发协商缓存，返回304，从缓存读数据，否则服务端会将新的请求结果返回，200。

### 浏览器缓存的数据都存在哪里？

浏览器的缓存主要有from memory cache内存缓存和from disk cache硬盘缓存，一般来说，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。

### 刷新操作和缓存的关系？

1、正常操作：地址栏输入url、前进后退

强制缓存有效、协商缓存有效

2、手动刷新：f5(commant + r)、点击刷新按钮、右击菜单刷新

强制缓存无效、协商缓存无效

3、强制刷新：ctrl+f5 （commant + shift+r）

强制缓存无效、协商缓存无效

# 3、浏览器渲染机制？进程线程？

### 浏览器渲染机制

1. 现代浏览器一般都是多进程的，它主要包括了：浏览器主进程、用于绘制的GPU进程、三方插件进程、浏览器渲染进程（也就是我们经常说的浏览器内核）
2. 每开一个tab页面，就是新开的一个浏览器渲染进程，他们互不影响，主要作用是：页面渲染、脚本执行、事件处理等等
3. 对每一个tab页来说，这个渲染进程里包含了多个线程协同运作，维持网站的运行。主要有GUI渲染线程、JS引擎线程（执行栈）、事件触发线程（任务队列）、定时触发线程（定时任务）、异步http请求线程（处理请求，状态变更时，放置任务队列带js引擎空闲后执行）
4. 这些线程运作主要是GUI渲染线程来处理页面的显示（dom树、css树、重排重绘绘制render树，然后由浏览器GPU合成图层、显示在屏幕上）；
5. 然后是js的逻辑处理，涉及到经常说的js事件循环机制，其实也就是由js引擎线程、定时触发线程、http请求线程和事件触发线程协同合作完成的。

### 具体从线程角度说说JS事件循环

1. js引擎线程就是js的执行栈，它会执行js的脚本逻辑，如果执行碰到定时任务，会交给定时触发线程去处理、如果碰到http请求，会交给异步http请求线程去处理，然后继续执行这个执行栈中的同步代码。
2. 执行完成后，js引擎线程会去查看事件触发线程中有没有排队的任务，比如一些http请求的响应、定时任务的回调等等，如果有的话，他会将排队的任务拎到执行栈中执行，依次循环
3. 另外这里涉及到一个宏任务和微任务，微任务优先。也就是说当执行栈中的同步代码执行完，js引擎会去查看微任务队列，将微任务清空，然后再去查看宏任务队列，将宏任务领一个过来到执行栈中执行，再去查看是否有新的微任务。
4. 直到完成所有的事件处理。

### 宏任务、微任务有哪些？有什么区别？

宏任务和微任务都是异步任务，是浏览器做的两种分类。常见的宏任务像我们经常用的一些setTimeout、setInterval之类的定时任务，还有IO；常见的微任务有Promise的回调函数then\catch\finally、promise的语法糖async-await后的内容。

1、宏任务和微任务的分类不同，如上所述

2、宏任务是一次执行一个，微任务是一次执行完所有微任务队列中的微任务

3、宏任务的定位更像是一个个独立的单元，他包括一些页面加载、定时器等等的内容，运行完后，浏览器可以继续其他调度，渲染页面UI或垃圾回收等等。

4、微任务的定位像是更小的任务，需要尽可能快的执行，让我们在渲染UI之前完成一些事情，避免不必要的重绘。

[参考文章](https://blog.csdn.net/weixin_43334673/article/details/109627290)

### 实例

参考这篇文章：[https://www.cnblogs.com/wangziye/p/9566454.html](https://www.cnblogs.com/wangziye/p/9566454.html)

# 4、前端安全？

**同源策略限制内容有：**

- Cookie、LocalStorage、IndexedDB 等存储性内容
- DOM 节点
- AJAX 请求发送后，结果被浏览器拦截了

但是有三个标签是允许跨域加载资源：

- `<img src=XXX>`
- `<link href=XXX>`
- `<script src=XXX>`

### 前端安全包含哪些内容？

所有发生在浏览器、单页面应用、Web页面当中的安全问题则算是“前端安全问题”，可以多注意：不安全的第三方依赖包、警惕XSS攻击和CSRF攻击、iframe的一些风险、本地存储数据的泄露等等。

### XSS攻击？

XSS是跨站脚本攻击，本质是，注入不属于页面本身的js脚本对网站进行攻击。

防御的方法主要是：警惕iframe风险，对数据进行严格编码，前后端都替换特殊字符<&lt >&gt，输入验证、接入xss的npm过滤工具等等。最常见的比如我们在vue当中v-html绑定dom数据的指令，或者我们将用户输入的数据作为js执行等等。因为没有加编码和数据校验，如果是用户输入的数据，可能会混有js的攻击脚本，影响安全性。

### csrf攻击？

csrf是跨站请求伪造，本质是，诱导攻击者进入三方网站，在三方网站向攻击网站发送跨站请求，拿到注册凭证，绕过后台的用户验证冒充用户对被攻击网站执行某项操作。比如在第三方网站诱导用户输入登录信息，跨站请求后端，拿到用户token，冒充用户操作。

**跨站请求方式**

图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。

**防御**

1、同源检测，组织不明外域的访问

2、使用post接口，因为post跨域是需要服务端验证的

3、提交时token校验、双重cookie验证之类

4、增加验证，如指纹、验证码等等

通常需要前后端同学的配合。

### 有遇到过具体的案例吗？

分别都举一下问卷里的例子，csrf要再调一下

**XSS**

有的，比如问卷当中，旧版问卷的一个问卷标题，原本是通过v-html绑定用户输入的标题内容，由此可以让用户手动输入html以绑定不同的标题样式。但是重构的时候就发现这种方式存在很大的风险，用户可以在html中绑定js脚本执行恶意文件，因此重构的时候就去掉了这种形式而是改了配置项让用户可以配置一些标题样式。

**CSRF**

对csrf攻击，有遇到一次，是安全同学提出来的，也是在问卷项目中。因为原本问卷的登录是个人用户可以登录以问卷后台，三方系统不需要登录（因为三方系统在本身系统中是登录过的,拿他们的token就行。）然后访问一些特定页面。但是三方系统不进行登录校验的话，不能保证这个token就是真实的我们自己的三方系统。

对这个问题的解决方案是加一层签名校验，不让用户二次登录，具体实现是：

1. 三方系统登录，有其本身的AC统一的token，当对面页面要访问问卷时，对方系统后端，请求问卷后端，问卷后端生成问卷访问地址和三方id，还有签名给三方后端，三方后端返回给前端
2. 前端跳转页面，进入问卷前端，问卷前端带着有时效性的签名请求后端，后端校验真实性，然后返回Token，将其写入cookie中，后续请求再根据token请求。
3. 如果签名失效，则三方系统要重新走登录流程，AC统一登录然后请求问卷后端换签名这一套。

（这个需要前后端同学一起商量方案）

# 5、http协议的发展历程？

### http发展的过程：http、https、http2.0？

1. http1.0是第一个正式版本，它支持get\post请求，也可以传输html文件以外其他类型的内容，但只支持`短连接`
2. http1.1就支持了`长连接`、引入了一些缓存策略和错误状态响应码，但是内容依旧是明文传输，不安全
3. 然后是https，它是在http基础上加了一层ssl安全套接字协议（或tls传输层安全协议）`加密`，连接方式和http有所不同，http是80端口，https是443端口
4. http1.X之后呢，就引入了https的加密传输，`强制使用ssl/tls加密传输`，客户端也可以`存储缓存`
5. http2.0增加了`多路复用、二进制格式传输`、报头压缩、`响应主动“推送”到客户端缓存`等等
6. http3.0有了更多的优化，阻塞问题解决的更好，关键是支持`切换网络时保持连接`

### https怎么保证安全性？

主要分为两个部分：**一是确保网站的真实性（CA认证），二是传输数据的SSL加密**

1、我们的https的网站，是需要申请认证证书的，CA认证就是一个权威组织，用于认证网站合法性，有了证书之后，传输密钥时可通过CA判断是否合法，避免”中间人攻击“。

2、对传输的http数据内容进行SSL加密，采用的方式是非对称加密和对称加密结合的办法（首先通过非对称加密传输公钥和私钥（公钥带上ca证书），客户端校验证书，生成key，用公钥加密，发给服务器，服务器用私钥解密，得到key，然后两者就可以通过对称加密的这个key传输数据）

**交换密钥的具体过程为：**

1. 客户端发起一个请求给服务器；
2. 服务器生成一对非对称的公钥（`pubkey`）和私钥（`privatekey`），然后把公钥附加到一个 `CA数字证书` 上返回给客户端；
3. 客户端校验该证书是否合法（通过浏览器内置的厂商根证书等手段校验），然后从证书中提取出公钥（`pubkey`）；
4. 客户端生成一个随机数（`key`），然后使用公钥（`pubkey`）对这个随机数进行加密后发送给服务器；
5. 服务器利用私钥（`privatekey`）对收到的随机数密文进行解密得到 `key` ;
6. 后续客户端和服务器传输数据使用该 `key` 进行加密后再传输；

### 抓包原理

抓包工具就相当于一个中间人，数据经过的时候它一只手接到数据，然后另一只手把数据传出去，对http和https有不同表现。

1、http就比较简单，因为是明文传输的，所以它作为一个中间人互相传递一下。

2、https的话，它的表现像是，在客户端面前，模仿服务端，在服务端面前假装客户端。然后它自己有一个证书。通过前面所说的交换密钥的过程，只是把自己的角色进行转换，然后给客户端和服务端互相传递数据（两者之间走的也是一样的加密解密这样的过程）

抓包原理看一下：[https://www.cnblogs.com/tester-xt/p/13174279.html](https://www.cnblogs.com/tester-xt/p/13174279.html)

### 常用的抓包工具抓https，浏览器（手机端）为什么要安装证书？

根据上面的抓包原理，在服务端把公钥和CA数字证书返回给客户端这一步时，对一般网站，客户端校验证书合法性，是依靠通过浏览器内置的厂商根证书等手段校验的，那么我们的抓包工具是没有对应的根证书，因此为了校验这个抓包工具身份能通过，需要在客户端安装我们抓包工具的根证书，用以在抓包工具返回CA和公钥模拟服务端这一步时，能够校验通过。

### 怎么理解1.0短连接，1.1长连接和2.0的多路复用的？

- HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个TCP连接；
- HTTP/1.1 一个TCP连接，keep-alive保持连接，可以传递多个http请求，但这些请求是串行化单线程处理的，一旦有某请求超时等，后续请求只能被阻塞，常说的**线头阻塞**；
- HTTP/2多个请求可同时在一个连接上**并行执行**。某个请求任务耗时严重，不会影响到其它连接的正常执行；它是二进制传输而非1.0的文本传输。

**具体的多路复用用例：**

http2.0引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据

### http2.0的服务端推送是什么？

服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。比如以前请求一个index.html,返回一个index.html。现在可以请求一个index.html，把他对应的js都一起返回。

# 6、http请求？

### HTTP报文组成

请求报文：请求行、请求头、（回车换行）、消息体

响应报文：状态行、响应头、（回车换行）、消息体

其中请求行：`GET /index.html HTTP/1.1`  请求方法（Method） 请求 URI  http协议版本

状态行：`HTTP/1.1 200 OK`    http协议版本  状态码 状态码的文本描述

请求头和响应头主要是包含一些头部字段，用来控制缓存、数据内容传递等等信息。

### 常见的状态码

- **1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码**
    - 100 - 继续 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分
    - 101 - 切换协议 请求者已要求服务器切换协议，服务器已确认并准备切换
- **2xx（成功）表示成功处理了请求的状态码**
    - 200 - 成功 服务器已经成功处理了请求。通常，这表示服务器提供了请求的网页
    - 203 - 非授权信息 服务器已经成功处理了请求，但返回的信息可能来自另一来源
    - 204 - 无内容 服务器成功处理了请求，但没有返回任何内容
    - 205 - 重置内容 服务器成功处理了请求，但没有返回任何内容
    - 206 - 部分内容 服务器成功处理了部分GET请求
- **3xx（重定向）表示要完成请求，需要进一步操作；通常，这些状态代码用来重定向**
    - 300 - 多种选择 针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择
    - 301 - 永久重定向，会自动将请求者转到新位置
    - 302 - 临时重定向
    - 303 - 查看其它位置 请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码
    - 304 - 未修改 自上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容（协商缓存）
    - 305 - 使用代理 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理
    - 307 - 临时性重定向 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求
- **4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理**
    - 400 - 错误请求 服务器不理解请求的语法
    - 401 - 未授权 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应
    - 403 - 禁止 服务器拒绝请求
    - 404 - 未找到 服务器找不到请求的网页
    - 405 - 方法禁用 禁用请求中指定的方法
    - 408 - 请求超时 服务器等候请求时发生超时
    - 410 - 已删除 如果请求的资源已永久删除，服务器就会返回此响应
    - 411 - 需要有效长度 服务器不接受不含有效内容长度标头字段的请求
    - 417 - 未满足期望值 服务器未满足“期望”请求标头字段的要求
- **5xx（服务器错误）这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错**
    - 500 - 服务器内部错误 服务器遇到错误，无法完成请求
    - 502 - 错误网关 服务器作为网关或代理，从上游服务器无法收到无效响应
    - 503 - 服务器目前暂时无法使用
    - 504 - 网关超时 服务器作为网关代理，但是没有及时从上游服务器收到请求
    - 505 - HTTP版本不受支持 服务器不支持请求中所用的HTTP协议版本

### 常见的请求头、响应头的字段

见[https://www.cnblogs.com/chunlei36/p/6927365.html](https://www.cnblogs.com/chunlei36/p/6927365.html)

**请求首部字段**

```jsx
Accept	              设置接受的内容类型
Accept-Charset: utf-8 设置接受的字符编码
Cache-Control 设置请求响应链上所有的缓存机制必须遵守的指令
Content-Type 设置请求体的MIME类型（适用POST和PUT请求）
Cookie 设置服务器使用Set-Cookie发送的http cookie
If-Match 设置客户端的ETag,当时客户端ETag和服务器生成的ETag一致才执行
Host	                请求的目标域名和端口号
If-Modified-Since	    比较资源的更新时间
If-None-Match	        比较实体标记
Origin: http://localhost:8081/ //请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息）
User-Agent //浏览器信息
Connection: keep-alive  //告诉服务器，客户端需要的tcp连接是一个长连接
```

响应头**字段**

```jsx
Cache-Control	控制缓存行为
Expires 缓存过期时间
Content-type 返回的数据格式
Content-length 返回的数据大小--字节
Content-Encoding: gzip  //采用gzip对资源进行解码
Access-Control-Allow-Origin 指定哪些站点可以参与跨站资源共享
Connection: keep-alive  //tcp是长连接
ETag 特定版本资源的标识符，文件内容hash
Last-Modified //最近一次文件修改时间
Set-Cookie 设置HTTP Cookie
Date	报文日期
Warning	错误通知
Date: //服务端发送资源时的服务器时间
Expires: //缓存过期时间
```

### 请求方式

根据HTTP标准，HTTP请求可以使用多种请求方法。HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。

```jsx
GET       请求指定的页面信息，并返回实体主体。
HEAD      类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
POST      向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。
					POST请求可能会导致新的资源的建立和/或已有资源的修改。
PUT       从客户端向服务器传送的数据取代指定的文档的内容。
DELETE    请求服务器删除指定的页面。
CONNECT   HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
OPTIONS   允许客户端查看服务器的性能。
TRACE     回显服务器收到的请求，主要用于测试或诊断。
```

### get和post的区别

- GET 参数通过 url 传递，POST 放在 body 中。（http 协议规定，url 在请求头中，所以大小限制很小）
- GET 请求在 url 中传递的参数是有长度限制的，而 POST 没有。原因见上↑↑↑
- GET 请求会被浏览器主动 缓存，而 POST 不会，除非手动设置
- GET 比 POST 更不安全
- 对参数的数据类型，GET 只接受 ASCII字符，而 POST 没有限制
- GET 请求只能进行 url(x-www-form-urlencoded)编码，而 POST 支持多种编码方式
- **GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包**。对于 GET 方式的请求，浏览器会把 http 的 header 和 data 一并发送出去，服务器响应200（返回数据）。而对于 POST，浏览器先发送 header，服务器响应100 continue，浏览器再发送 data，服务器响应200 ok（返回数据）

### options预检请求

对`复杂跨域请求`，在真正的请求发送出去之前，浏览器会先发送一个options请求`向服务询问此接口是否允许访问`。它主要用来校验安全性和获取服务器支持的http请求方法。

三种情况会触发options预检请求：

1、请求方法是PUT、DELETE

2、POST请求的content-type不是application/x-www-form-urlencoded、multipart/form-data、text/plain

3、请求设置了自定义的header字段，我们的Content-Type绝大多数是application/json，会触发预检请求

# 7、浏览器存储？

浏览器存储基本都是存放在内存中，如果cookie过期时间很长的，可能会在硬盘空间中存储。

[Untitled](https://www.notion.so/c9f79374dc6049bcb1c48baacbfa6fed)

# 8、同源策略和跨域？

### 一级域名、二级域名、三级域名是什么？

我们接触的顶级域名(一级域名)又分为两类：一是国家和地区顶级域名，例如中国是cn；二是国际顶级域名，例如表示工商企业的.com，表示非盈利组织的.org，表示网络商的.net，edu为学校单位，.gov为政府机构等

以https://wy.guahao.com来说，域名中间有两个. 它是个二级域名，其中guahao 是一级域名，一般申请域名，如果是申请了一级域名，那后面的二三级就都是免费的。如果还有一层 https://wenzhen.wy.guahao.com,那这就是一个三级域名。

### 什么是浏览器的同源策略？

同源，指的是`协议、端口、域名`三者都要一致，才能称之为同源，不同域名指向一个ip也不行

**同源策略限制内容有：**

- Cookie、LocalStorage、IndexedDB 等存储性内容
- DOM 节点
- AJAX 请求发送后，结果被浏览器拦截了

但是有三个标签是允许跨域加载资源：

- `<img src=XXX>`
- `<link href=XXX>`
- `<script src=XXX>`

### 同源策略如何保证网站安全？

**关键词：存储、dom和ajax**

（1） 无法用js读取非同源的Cookie、LocalStorage 和 IndexDB 无法读取。防止恶意网站通过js获取用户其他网站的cookie。

（2） 无法用js获取非同源的DOM ，比如获取不到iframe中的内容。不然就可以iframe获取到整个三方页面了

（3） 无法用js发送非同源的AJAX请求 ，保证数据安全。

### 如果要跨域，要怎么解决？

纯前端侧：

1. jsonp
2. nginx代理
3. node中间层转发
4. postMessage—-iframe传参
5. websoket双向通信
6. 二级域名相同的情况下，比如 `a.test.com` 和 `b.test.com` ，可以给页面添加 `document.domain ='test.com'` 表示二级域名都相同就可以实现跨域。原理是让js设置domain为一级域名来实现

后端侧：

1. 让后端支持Cors跨域

### 有什么实际的跨域问题的解决吗？

**prd项目基于node服务解决跨域**

1. 仓库中我们分了app前端、server（node服务端）和electron客户端三个目录，app前端要请求gitlab的资源，但是我们应用共享后台和运维申请的域名是guahao-test，我们公司gitlab的请求接口都是[https://git.guahao-inc.com/](https://git.guahao-inc.com/)，如果直接请求会跨域。
2. 为了解决这个问题，同时也将我们node服务部署在前端服务器，存储一些敏感用户信息，还有要拉取git仓库目录存储到服务器中，再用nginx代理将所有仓库index.html展示在页面做共享，我们需要用到node层。
3. 具体的操作是，app前端ajax接口请求地址是node提供的guahao-test服务地址，然后node对特定的路由，不同的接口请求信息进行转发，再请求gitlab服务、或者调用本地git命令、或者操作文件等一系列的操作，同时node还可以做过滤（只支持get和post请求）

```jsx
// 前端配置：
# PRD Server GitLab 代理服务地址（增设代理服务主要是解决跨域请求问题）
REACT_APP_GITLAB_PROXY_SERVER=http://prd.guahao-test.com/gitlab
# PRD Server 地址
REACT_APP_PRD_SERVER=http://prd.guahao-test.com

// node端处理
const app = express();
...
const filter = function (pathname, req) {
  return ['GET', 'POST'].includes(req.method);
};
app.use(
  '/gitlab',
  createProxyMiddleware(filter, {
    target: process.env.GITLAB_SERVER, // GITLAB_SERVER=https://git.guahao-inc.com
    changeOrigin: true,
    pathRewrite: {
      '^/gitlab': '/',
    },
    headers: {
      'Private-Token': process.env.ACCESS_TOKEN,
    },
  }),
);

app.use('/api', require('./routes/api'));
app.use('/download-app', require('./routes/download-app'));
```

**非node项目跨域问题解决（本地跨域）**

一般在开发和测试环境，前端要请求测试地址的后端服务，在vue项目中设置跨域请求的webpack的proxy配置：这样对我们的所有/api接口设置代理请求，方便请求测试环境或者和后端本地联调

```jsx
proxy: {
      '/api': 
        {
          // target: 'http://172.28.75.142:8080',
          target: 'http://ipm-his-web-service-qa2.guahao-test.com',
          changeOrigin: true // 必须设置
        }
    },
    headers: {
      // Friday: 配置允许跨域请求所有静态资源
      'Access-Control-Allow-Origin': '*'
    }
```

**proxy的工作原理：**[https://www.jianshu.com/p/8fd5d7347c57](https://www.jianshu.com/p/8fd5d7347c57)

也是基于node代理中间件的形式。

`proxy`只是一层代理，用于把指定的`path`，代理去后端提供的地址，他的背后也是使用node来做server，实质上是利用`http-proxy-middleware` 这个http代理中间件，实现请求转发给其他服务器。

**为什么只适用本地开发？**因为该技术只是在webpack打包阶段在本地临时起了一个node server服务，来实现类似nginx 的`proxy_pass`的反向代理效果。

# 9、关于websocket?

### 什么是websocket？

WebSocket 是一种网络通信协议，它可以解决服务端主动向客户端推送消息的需求。

### 有什么特点？

（1）建立在 TCP 协议之上，服务器端的实现比较容易。

（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

（3）数据格式比较轻量，性能开销小，通信高效。

（4）可以发送文本，也可以发送二进制数据。

（5）没有同源限制，客户端可以与任意服务器通信。

（6）协议标识符是`ws`（如果加密，则为`wss`），服务器网址就是 URL。

> ws://example.com:80/some/path

### 长轮询和短轮询

**长轮询：**客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。

**短轮询：**客户端设置一个定时器，不间断地向服务器发送请求。

### 有实际使用过吗？

mock过，自己用node模拟了一下服务接收发送。

```jsx
var ws = new WebSocket("wss://echo.websocket.org");

ws.onopen = function(evt) { 
  console.log("Connection open ..."); 
  ws.send("Hello WebSockets!");
};

// 实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。
ws.onmessage = function(evt) {
  console.log( "Received Message: " + evt.data);
  ws.close();
};

ws.onclose = function(evt) {
  console.log("Connection closed.");
};

ws.send('your message'); // 实例对象的send()方法用于向服务器发送数据。
```