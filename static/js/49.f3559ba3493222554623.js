webpackJsonp([49],{"58bh":function(v,_,e){"use strict";Object.defineProperty(_,"__esModule",{value:!0});var t={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("section",[e("p",[v._v("问题列表：")]),v._v(" "),e("ol",[e("li",[v._v("重排和重绘")]),v._v(" "),e("li",[v._v("css实现绘制三角形")]),v._v(" "),e("li",[v._v("行内元素、块元素")]),v._v(" "),e("li",[v._v("盒子模型")]),v._v(" "),e("li",[v._v("css选择器")]),v._v(" "),e("li",[v._v("块级格式化上下文BFC")]),v._v(" "),e("li",[v._v("flex布局")]),v._v(" "),e("li",[v._v("伪类、伪元素")]),v._v(" "),e("li",[v._v("bem方法命名规范")]),v._v(" "),e("li",[v._v("@media 媒体查询")]),v._v(" "),e("li",[v._v("css的单位")])]),v._v(" "),e("h2",[v._v("Q1：重排和重绘？")]),v._v(" "),e("p",[v._v("原文链接："),e("a",{attrs:{href:"https://blog.csdn.net/qq_27674439/article/details/98957581"}},[v._v("https://blog.csdn.net/qq_27674439/article/details/98957581")])]),v._v(" "),e("h3",[e("strong",[v._v("浏览器的运行机制：布局")])]),v._v(" "),e("p",[v._v("1、构建DOM树（parse）")]),v._v(" "),e("p",[v._v("渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node（包括js生成的标签）生成内容树（Content Tree/DOM Tree）；")]),v._v(" "),e("p",[v._v("2、构建渲染树（construct）")]),v._v(" "),e("p",[v._v("解析对应的CSS样式文件信息（包括js生成的样式和外部css文件），而这些文件信息以及HTML中可见的指令（如），构建渲染树（Rendering Tree/Frame Tree）；")]),v._v(" "),e("p",[v._v("3、布局渲染树（reflow/layout）")]),v._v(" "),e("p",[v._v("从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标；")]),v._v(" "),e("p",[v._v("4、绘制渲染树（paint/repaint）")]),v._v(" "),e("p",[v._v("遍历渲染树，使用UI后端层来绘制每个节点。")]),v._v(" "),e("h3",[e("strong",[v._v("重排重绘")])]),v._v(" "),e("p",[v._v("重排（重构/回流/reflow）：布局大小改变")]),v._v(" "),e("p",[v._v("当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。")]),v._v(" "),e("p",[v._v("重绘（repaint或redraw）：外观属性改变")]),v._v(" "),e("p",[v._v("当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。")]),v._v(" "),e("p",[e("strong",[v._v("关系：")])]),v._v(" "),e("p",[v._v("在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。")]),v._v(" "),e("p",[v._v("所以，"),e("strong",[v._v("重排必定会引发重绘，但重绘不一定会引发重排。")])]),v._v(" "),e("h3",[e("strong",[v._v("优化方案：")])]),v._v(" "),e("ol",[e("li",[e("p",[v._v("浏览器的优化：")]),v._v(" "),e("p",[v._v("浏览器会维护队列批处理，让多次的回流、重绘变成一次回流重绘。")])])]),v._v(" "),e("p",[v._v("2、我们的优化：")]),v._v(" "),e("p",[v._v("总结一句话就是：减少对渲染树的操作，合并多次DOM和样式的修改，并减少对style样式的请求。")]),v._v(" "),e("p",[v._v("（1）直接改变元素的className")]),v._v(" "),e("p",[v._v("（2）display：none；先设置元素为display：none；然后进行页面布局等操作；设置完成后将元素设置为display：block；这样的话就只引发两次重绘和重排；")]),v._v(" "),e("p",[v._v("（3）不要经常访问浏览器的flush队列属性；如果一定要访问，可以利用缓存。将访问的值存储起来，接下来使用就不会再引发回流；")]),v._v(" "),e("p",[v._v("（4）使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；")]),v._v(" "),e("p",[v._v("（5）将需要多次重排的元素，position属性设为absolute或fixed，元素脱离了文档流，它的变化不会影响到其他元素；")]),v._v(" "),e("p",[v._v("（6）如果需要创建多个DOM节点，可以使用DocumentFragment创建完后一次性的加入document；")]),v._v(" "),e("p",[v._v("（7）尽量不要使用table布局。")]),v._v(" "),e("h2",[v._v("Q2：CSS怎么实现绘制三角形？")]),v._v(" "),e("p",[v._v("将盒子宽高设为0，利用盒子的边框及"),e("code",[v._v("transparent透明属性")]),v._v("，如：")]),v._v(" "),e("pre",[e("code",{staticClass:"language-jsx"},[v._v("div {\n\t"),e("span",{staticClass:"hljs-attr"},[v._v("width")]),v._v(": "),e("span",{staticClass:"hljs-number"},[v._v("0")]),v._v("px;\n\theight: "),e("span",{staticClass:"hljs-number"},[v._v("0")]),v._v("px;\n  border-bottom: "),e("span",{staticClass:"hljs-number"},[v._v("100")]),v._v("px solid red;\n  border-left: "),e("span",{staticClass:"hljs-number"},[v._v("50")]),v._v("px solid transparent;\n  border-right: "),e("span",{staticClass:"hljs-number"},[v._v("50")]),v._v("px solid transparent;\n}\n")])]),v._v(" "),e("h2",[v._v("Q3:  行内元素、块元素")]),v._v(" "),e("p",[e("strong",[v._v("常见行内元素：")])]),v._v(" "),e("p",[e("span",[v._v("、"),e("a",[v._v("、"),e("label",[v._v("、"),e("input"),v._v("、"),e("textarea",[v._v("、")]),e("select",[v._v("、 "),e("img"),v._v("、 "),e("strong",[v._v("、"),e("em")])])])])])]),v._v(" "),e("p",[e("strong",[v._v("常见块元素：")])]),v._v(" "),e("div",[v._v("、 "),e("p",[v._v("、")]),e("h1",[v._v("、"),e("form",[v._v("、"),e("ul",[v._v(" 、"),e("li",[e("p",[e("strong",[v._v("默认的天生inline-block元素（拥有内在尺寸，可设置高宽，但不会自动换行），有哪些？")])]),v._v(" "),e("p",[v._v("答案："),e("input"),v._v(" 、"),e("img"),v._v(" 、"),e("button",[v._v(" 、")]),e("textarea",[v._v("。")])]),v._v(" "),e("p",[e("strong",[v._v("特点：")])]),v._v(" "),e("ol",[e("li",[v._v("行内元素和其他元素一行展示，不可设置宽高，内容撑开宽度。设置上下padding、margin无效，左右有效")]),v._v(" "),e("li",[v._v("块元素独占一行，可设宽高和边距，没有设置宽度是，是父容器的100%。")])]),v._v(" "),e("p",[e("strong",[v._v("display可以修改元素属性，常用的"),e("code",[v._v("display")]),v._v("属性值有：")])]),v._v(" "),e("ol",[e("li",[e("code",[v._v("inline")]),v._v(" 行内")]),v._v(" "),e("li",[e("code",[v._v("block")]),v._v(" 块")]),v._v(" "),e("li",[e("code",[v._v("inline-block")]),v._v("  行内块")]),v._v(" "),e("li",[e("code",[v._v("none")]),v._v(" 不展示，不占位")])]),v._v(" "),e("h2",[v._v("Q4：盒子模型")]),v._v(" "),e("p",[v._v("盒模型的组成，由里向外 content,padding,border,margin.")]),v._v(" "),e("ol",[e("li",[v._v("在标准的盒子模型中，width指content部分的宽度")]),v._v(" "),e("li",[v._v("在IE盒子模型中，width表示"),e("strong",[v._v("content+padding+border")]),v._v("这三个部分的宽度")])]),v._v(" "),e("p",[e("strong",[v._v("box-sizing的使用：")])]),v._v(" "),e("p",[v._v("box-sizing: content-box 是W3C盒子模型")]),v._v(" "),e("p",[v._v("box-sizing: border-box 是IE盒子模型")]),v._v(" "),e("p",[v._v("box-sizing的默认属性是content-box")]),v._v(" "),e("h2",[v._v("Q5：css选择器")]),v._v(" "),e("p",[v._v("1）标签选择器 p")]),v._v(" "),e("p",[v._v("2）ID 选择器 #id")]),v._v(" "),e("p",[v._v("3）类选择器 .class")]),v._v(" "),e("p",[v._v("4）通配符 *")]),v._v(" "),e("p",[v._v("5）派生选择器 以空格连接多个选择器，表示 ... 的后代，可以隔代")]),v._v(" "),e("p",[v._v("6）子元素选择器 以 > 连接多个选择器，表示 ... 的子元素，不能隔代")]),v._v(" "),e("p",[v._v("7）相邻选择器 以 + 连接多个选择器，表示紧跟在 ... 的兄弟元素")]),v._v(" "),e("p",[v._v("8）分组选择器 以逗号连接多个选择器，同时选中这些没有关联的选择器")]),v._v(" "),e("p",[v._v("9）属性选择器 以 [] 来根据元素的属性名和属性值来选中具有对应信息的元素，可以写多个 [] 来多属性匹配，也可以根据具体的属性值来匹配，还可以通过正则来进行更复杂的匹配；")]),v._v(" "),e("p",[e("a",{attrs:{href:"https://link.zhihu.com/?target=https%3A//www.w3school.com.cn/css/css_selector_attribute.asp"}},[v._v("属性选择器详解")])]),v._v(" "),e("p",[v._v("10）伪类 以单冒号开头，可以找到不能用常规选择器获取到不存在 DOM 树中的信息，可以同时使用多个伪类")]),v._v(" "),e("p",[v._v("11）伪元素 以双冒号开头，可以像真正的元素那样去展现行为，但并不是真正的元素，只能同时使用一个伪元素。")]),v._v(" "),e("p",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/118174713"}},[v._v("常用的伪类和伪元素")])]),v._v(" "),e("h3",[v._v("1、简单选择器的使用")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("标签选择器（又名：元素选择器）  div{}")])]),v._v(" "),e("li",[e("p",[v._v("类选择器（Class selectors）.box1{}")])]),v._v(" "),e("li",[e("p",[v._v("ID 选择器  #selectid {}")])]),v._v(" "),e("li",[e("p",[v._v("通用选择器（Universal selector）  * {}")])]),v._v(" "),e("li",[e("p",[v._v("组合器（Combinators）")]),v._v(" "),e("p",[v._v("a,b  A（和/或）B的任意元素.")]),v._v(" "),e("p",[v._v("a b  B是A的后代结点")]),v._v(" "),e("p",[v._v("a>b b是a的直接子节点")]),v._v(" "),e("p",[v._v("a+b ab是兄弟节点")])])]),v._v(" "),e("h3",[v._v("2、权重")]),v._v(" "),e("p",[v._v("!important > 行内 1000 >内部>外部样式,  ID 100>class 10>元素 1")]),v._v(" "),e("p",[v._v("从左往右逐个等级比较，前一等级相等才往后比")]),v._v(" "),e("p",[v._v("1）内联样式")]),v._v(" "),e("p",[v._v("2）ID 选择器")]),v._v(" "),e("p",[v._v("3）类选择器、伪类、属性选择器")]),v._v(" "),e("p",[v._v("4）标签选择器、伪元素选择器")]),v._v(" "),e("p",[v._v("5）通配符、子元素选择器、相邻选择器、派生选择器、分组选择器")]),v._v(" "),e("h2",[v._v("Q6: 块级格式化上下文（BFC）")]),v._v(" "),e("p",[v._v("更多可见：")]),v._v(" "),e("p",[e("a",{attrs:{href:"https://blog.csdn.net/sinat_36422236/article/details/88763187"}},[v._v("什么是BFC？看这一篇就够了_Leon的博客-CSDN博客_bfc")])]),v._v(" "),e("p",[e("a",{attrs:{href:"https://www.cnblogs.com/qs-cnblogs/p/12349887.html"}},[v._v("BFC是什么？BFC有什么用？看完全明白")])]),v._v(" "),e("h3",[v._v("什么是BFC？")]),v._v(" "),e("blockquote",[e("p",[v._v("BFC全称是block formatting context，块级格式化上下文。其中FC 指的就是一个渲染区域，有一套既定的规则，比如定义子元素怎么定位，和其他元素的关系及相互作用。BFC它表示的是一个独立的块级布局环境，有一定的功能和特性，我们可以利用这些特性来完成一些布局或者解决一些样式问题。另外还会有IFC，行内格式化上下文，提到的相对少一些。")])]),v._v(" "),e("h3",[e("strong",[v._v("元素产生BFC的条件：根、浮动、overflow、display、position")])]),v._v(" "),e("p",[v._v("1、根元素（")]),e("html",[v._v("）就是一个BFC区域")]),e("p"),v._v(" "),e("p",[v._v("2、float属性不为none（脱离文档流）")]),v._v(" "),e("p",[v._v("3、overflow值非visible")]),v._v(" "),e("p",[v._v("4、display值为inline-block、table-cell、table-caption、flex、inline-flex")]),v._v(" "),e("p",[v._v("5、position值为absolute、fixed")]),v._v(" "),e("h3",[e("strong",[v._v("BFC元素所具有的特性")])]),v._v(" "),e("p",[v._v("1、属于同一个BFC的两个相邻容器的上下margin会重叠（重点）")]),v._v(" "),e("p",[v._v("比如根元素下两个box外边距塌陷，那么可以给另一个容器再套一层，形成一个新的BFC")]),v._v(" "),e("p",[v._v("2、计算BFC高度时浮动元素也参于计算（重点）")]),v._v(" "),e("p",[v._v("用于清除浮动，给浮动元素的父元素添加overflow:hidden；这样父元素如果没有设置高度也不会让浮动元素超出父元素外了")]),v._v(" "),e("p",[v._v("3、BFC的区域不会与浮动容器发生重叠（重点）")]),v._v(" "),e("p",[v._v("应用于自适应两栏布局，给浮动元素的兄弟元素设置BFC，则这个元素就不会被遮挡。")]),v._v(" "),e("p",[v._v("4、BFC内的容器在垂直方向依次排列")]),v._v(" "),e("p",[v._v("5、元素的margin-left与其包含块的border-left相接触")]),v._v(" "),e("p",[v._v("6、BFC是独立容器，容器内部元素不会影响容器外部元素")]),v._v(" "),e("p",[e("strong",[v._v("应用场景")])]),v._v(" "),e("p",[v._v("1、可以利用BFC解决两个相邻元素的上下margin重叠问题；")]),v._v(" "),e("p",[v._v("2、可以利用BFC解决高度塌陷问题、清除内部浮动；")]),v._v(" "),e("p",[v._v("3、可以利用BFC实现多栏布局（两栏、三栏、圣杯、双飞翼等）。")]),v._v(" "),e("h3",[v._v("IFC")]),v._v(" "),e("blockquote",[e("p",[v._v("在行内格式化上下文中，框(boxes)一个接一个地水平排列，起点是包含块的顶部。水平方向上的 margin，border 和 padding在框之间得到保留。框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐。包含那些框的长方形区域，会形成一行，叫做行框。")])]),v._v(" "),e("h2",[v._v("Q7： flex弹性布局")]),v._v(" "),e("p",[e("strong",[v._v("基本概念")])]),v._v(" "),e("p",[v._v("一种新的响应式布局方案，用来为盒状模型提供最大的灵活性")]),v._v(" "),e("p",[v._v("任何一个容器都可以指定为Flex布局。")]),v._v(" "),e("p",[e("strong",[v._v("容器属性")])]),v._v(" "),e("ol",[e("li",[e("p",[e("strong",[v._v("flex-direction  row | row-reverse | column | column-reverse;")])]),v._v(" "),e("p",[v._v("决定主轴的方向（即项目的排列方向）")])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("flex-wrap nowrap | wrap | wrap-reverse（换行，第一行在下方）;")])]),v._v(" "),e("p",[v._v("如果一条轴线排不下，如何换行。")])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("flex-flow")])]),v._v(" "),e("p",[v._v("是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap")])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("justify-content   flex-start | flex-end | center | space-between | space-around;")])]),v._v(" "),e("p",[v._v("定义了项目在主轴上的对齐方式。")])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("align-items flex-start | flex-end | center | baseline | stretch;")])]),v._v(" "),e("p",[v._v("定义项目在交叉轴上如何对齐。顶部对齐|底部|中间|文字基线|拉长上下对齐")])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("align-content flex-start | flex-end | center | space-between | space-around | stretch;")])]),v._v(" "),e("p",[v._v("定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用")])])]),v._v(" "),e("p",[e("strong",[v._v("项目属性")])]),v._v(" "),e("ol",[e("li",[e("code",[v._v("order")]),v._v(" 定义项目的排列顺序。数值越小，排列越靠前，默认为0")]),v._v(" "),e("li",[e("code",[v._v("flex-grow")]),v._v("项目的放大比例，默认为0，即如果存在剩余空间，也不放大")]),v._v(" "),e("li",[e("code",[v._v("flex-shrink")]),v._v(" 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小")]),v._v(" "),e("li",[v._v("flex-basis 定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。")]),v._v(" "),e("li",[v._v("flex flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选")]),v._v(" "),e("li",[v._v("align-self允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch")])]),v._v(" "),e("h2",[v._v("Q8： 伪类，伪元素")]),v._v(" "),e("p",[v._v("用法："),e("a",{attrs:{href:"https://www.cnblogs.com/lomon6/p/10585885.html"}},[v._v("https://www.cnblogs.com/lomon6/p/10585885.html")])]),v._v(" "),e("h3",[v._v("伪类")]),v._v(" "),e("blockquote",[e("p",[v._v("伪类存在的意义是为了通过选择器找到那些不存在与DOM树中的信息以及不能被常规CSS选择器获取到的信息。")])]),v._v(" "),e("blockquote",[e("p",[v._v("伪类由一个冒号:开头，冒号后面是伪类的名称和包含在圆括号中的可选参数。")])]),v._v(" "),e("p",[v._v("CSS 伪类用于向某些选择器添加特殊的效果。匹配处于确定状态的一个或多个元素，比如被鼠标指针悬停的元素，或当前被选中或未选中的复选框，或元素是 DOM 树中一父节点的第一个子节点。")]),v._v(" "),e("p",[e("strong",[v._v("常见的伪类：")])]),v._v(" "),e("p",[v._v(":link 将样式添加到未被访问过的链接")]),v._v(" "),e("p",[v._v(":visited  将样式添加到访问过的链接")]),v._v(" "),e("p",[v._v(":hover 鼠标悬停")]),v._v(" "),e("p",[v._v(":focus 被选中")]),v._v(" "),e("p",[v._v(":active 被激活，用鼠标点击时，元素增加特效")]),v._v(" "),e("p",[e("code",[v._v(":first-child第一个子元素")])]),v._v(" "),e("p",[e("code",[v._v(":nth-child() 子类")])]),v._v(" "),e("pre",[e("code",{staticClass:"language-jsx"},[v._v("tr:nth-child("),e("span",{staticClass:"hljs-number"},[v._v("2n")]),v._v("+"),e("span",{staticClass:"hljs-number"},[v._v("1")]),v._v("):nth-child("),e("span",{staticClass:"hljs-number"},[v._v("5n")]),v._v(") {\n"),e("span",{staticClass:"hljs-comment"},[v._v("// p匹配能够被5整除的奇数行")]),v._v("\n}\n")])]),v._v(" "),e("h3",[v._v("伪元素")]),v._v(" "),e("blockquote",[e("p",[v._v("伪元素在DOM树中创建了一些抽象元素，这些抽象元素是不存在于文档语言里的（可以理解为html源码）。比如：documen接口不提供访问元素内容的第一个字或者第一行的机制，而伪元素可以使开发者可以提取到这些信息。并且，一些伪元素可以使开发者获取到不存在于源文档中的内容（比如常见的::before,::after）。")])]),v._v(" "),e("blockquote",[e("p",[v._v("伪元素的由两个冒号::开头，然后是伪元素的名称。")])]),v._v(" "),e("p",[v._v("匹配处于相关的确定位置的一个或多个元素，例如每个段落的第一个字，或者某个元素之前生成的内容。")]),v._v(" "),e("p",[e("strong",[v._v("常见的伪元素：")])]),v._v(" "),e("p",[v._v("::first-letter 向文本的第一个字母添加特殊样式")]),v._v(" "),e("p",[v._v("::first-line 向文本的第一行添加特殊样式")]),v._v(" "),e("p",[v._v("::before 在元素之前添加内容")]),v._v(" "),e("p",[v._v("::after 在元素之后添加内容")]),v._v(" "),e("h3",[v._v("特性及其区别")]),v._v(" "),e("ol",[e("li",[v._v("伪类本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息；")]),v._v(" "),e("li",[v._v("伪元素本质上是创建了一个有内容的虚拟容器；")]),v._v(" "),e("li",[v._v("CSS3中伪类和伪元素的语法不同；")]),v._v(" "),e("li",[v._v("可以同时使用多个伪类，而只能同时使用一个伪元素；")])]),v._v(" "),e("h2",[v._v("Q9： bem方法命名规范")]),v._v(" "),e("p",[v._v("BEM（Block: 块, Element: 元素, Modifier: 修饰符）是一种基于组件的Web开发方法，基本思想是将用户界面划分为独立的块。这样即使拿到的UI设计稿在复杂，也可以轻松快速地进行拆分，只需要按照特定格式的命名约定，使得前端代码更易于阅读理解，并且是可扩展的，便于团队协作后期维护。")]),v._v(" "),e("p",[v._v("1、所有单词一律小写")]),v._v(" "),e("p",[v._v("2、单词之间用 - 分隔，命名尽量不要超过三个单词，避免命名过长")]),v._v(" "),e("p",[v._v("3、元素名称（Element）通过 __ 与块名称（Block）分隔")]),v._v(" "),e("p",[v._v("4、修饰符名称（Modifier）通过 -- 与块（Block）或元素（Element）名称分隔")]),v._v(" "),e("h2",[v._v("Q10： @media"),e("strong",[v._v("媒体查询")])]),v._v(" "),e("p",[v._v("Media Queries能在不同的条件下使用不同的样式，使页面在不同在终端设备下达到不同的渲染效果，@media 媒体类型and （媒体特性）{你的样式}")]),v._v(" "),e("p",[v._v("如：当屏幕小于或等于480px时,页面中的广告区块（.ads）都将被隐藏。")]),v._v(" "),e("p",[e("strong",[v._v("@media screen and (max-width:480px)")])]),v._v(" "),e("pre",[e("code",{staticClass:"language-jsx"},[v._v("@media screen and (max-width:"),e("span",{staticClass:"hljs-number"},[v._v("480")]),v._v("px){\n\n.ads {\n\n"),e("span",{staticClass:"hljs-attr"},[v._v("display")]),v._v(":none;\n\n"),e("span",[v._v("}}")]),v._v("\n")])]),v._v(" "),e("p",[v._v("参考："),e("a",{attrs:{href:"https://www.runoob.com/cssref/css3-pr-mediaquery.html"}},[v._v("https://www.runoob.com/cssref/css3-pr-mediaquery.html")])]),v._v(" "),e("h2",[v._v("Q12：CSS单位")]),v._v(" "),e("p",[v._v("总共列了 17 个单位：")]),v._v(" "),e("p",[v._v("% 百分比、cm 里面、mm 毫米、px 像素（计算机屏幕上的一个点）、in 英寸、pt 磅rgb(x,x,x)")]),v._v(" "),e("ol",[e("li",[v._v("rgb(x%,x%,x%) #rrggbb（十六进制）")]),v._v(" "),e("li",[v._v("em：1em 等于当前字体尺寸（继承父元素的字体尺寸）")]),v._v(" "),e("li",[v._v("rem：r 为 root，1rem 等于根元素字体尺寸（继承 html 的字体尺寸）")]),v._v(" "),e("li",[v._v("vh：1vh 等于可视窗口高度的 1/100")]),v._v(" "),e("li",[v._v("vw: 1vw 等于可视窗口宽度的 1/100")]),v._v(" "),e("li",[v._v("vmin：可视窗口宽高更小的值的 1/100")]),v._v(" "),e("li",[v._v("vmax：可视窗口宽高更大的值的 1/100")]),v._v(" "),e("li",[v._v("ex：当前字体的一个 x-height，一般为当前字体的一个 em 的一半，因为一个 'x' 字母一般为字体大小的一半")]),v._v(" "),e("li",[v._v("ch：设置 width:40ch 表示这个宽度可以容纳 40 个特定字体的字符")])]),v._v(" "),e("h2",[v._v("Q13：rem 布局的优缺点")]),v._v(" "),e("p",[v._v("相对于 em 的好处是：")]),v._v(" "),e("p",[v._v("不会发生逐渐增大或者减小字体尺寸的情况，因为"),e("code",[v._v("始终继承根元素的字体尺寸；")])]),v._v(" "),e("p",[v._v("rem 单位不仅可应用于字体大小，还可以用于设定宽高等其他大小，使页面可以适配不同屏幕尺寸。")]),v._v(" "),e("p",[v._v("rem 一般只用于移动端。")])])])])])])])}]},s=e("VU/8")(null,t,!1,null,null,null);_.default=s.exports},"x7e/":function(v,_,e){v.exports=e("58bh")}});
//# sourceMappingURL=49.f3559ba3493222554623.js.map