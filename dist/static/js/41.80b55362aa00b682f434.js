webpackJsonp([41],{"M9a/":function(_,v,t){"use strict";Object.defineProperty(v,"__esModule",{value:!0});var e={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("section",[t("p",[_._v("来全面的了解一下http、https、http1.0、http2.0、http3.0的知识吧，让我们把他们合理地串起来")]),_._v(" "),t("p",[_._v("参考文章：")]),_._v(" "),t("p",[t("a",{attrs:{href:"https://blog.csdn.net/striveb/article/details/84230923"}},[_._v("HTTP1.0和HTTP2.0的区别，以及HTTP和HTTPS的区别_striveb的博客-CSDN博客_http1.0和http2.0的区别")])]),_._v(" "),t("p",[t("a",{attrs:{href:"https://blog.csdn.net/glpghz/article/details/106063833"}},[_._v("HTTP1.0、HTTP2.0、HTTP 3.0及HTTPS简要介绍_长不大的大灰狼-CSDN博客_http3.0")])]),_._v(" "),t("h1",[_._v("一、HTTP是什么？")]),_._v(" "),t("h3",[_._v("定义")]),_._v(" "),t("blockquote",[t("p",[t("code",[_._v("超文本传输协议")]),_._v("，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。")])]),_._v(" "),t("blockquote",[t("p",[_._v("设计HTTP的初衷是为了"),t("code",[_._v("提供一种发布和接收HTML页面的方法")]),_._v("。")])]),_._v(" "),t("h3",[_._v("http的发展")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("http 0.9")]),_._v(" "),t("p",[_._v("只有get请求，不支持文本传输，还未成为标准协议")])]),_._v(" "),t("li",[t("p",[_._v("http 1.0")]),_._v(" "),t("ul",[t("li",[_._v("请求与响应支持 HTTP 头，响应含状态行，增加了状态码，")]),_._v(" "),t("li",[_._v("支持 HEAD，POST 方法")]),_._v(" "),t("li",[_._v("支持传输 HTML 文件以外其他类型的内容")]),_._v(" "),t("li",[t("code",[_._v("短连接")])])])]),_._v(" "),t("li",[t("p",[_._v("http1.1")]),_._v(" "),t("ul",[t("li",[_._v("支持"),t("code",[_._v("长连接")]),_._v("。")]),_._v(" "),t("li",[_._v("在HTTP1.0的基础上引入了更多的"),t("code",[_._v("缓存控制策略")]),_._v("。")]),_._v(" "),t("li",[_._v("引入了请求范围设置，优化了带宽。")]),_._v(" "),t("li",[_._v("在错误通知管理中新增了"),t("code",[_._v("错误状态响应码")]),_._v("。")]),_._v(" "),t("li",[_._v("增加了Host头处理，可以传递主机名（hostname）")]),_._v(" "),t("li",[t("code",[_._v("传输内容是明文，不安全")])])])]),_._v(" "),t("li",[t("p",[_._v("https")]),_._v(" "),t("ul",[t("li",[_._v("HTTPS运行在"),t("code",[_._v("安全套接字协议(Secure Sockets Layer，SSL )")]),_._v("或"),t("code",[_._v("传输层安全协议（Transport Layer Security，TLS）")]),_._v("之上，所有在TCP中传输的内容都需要经过"),t("code",[_._v("加密")]),_._v("。")]),_._v(" "),t("li",[_._v("连接方式不同，HTTP的端口是80，HTTPS的端口是443.")]),_._v(" "),t("li",[_._v("有效防止运营商劫持。")])])]),_._v(" "),t("li",[t("p",[_._v("http 1.x优化（SPDY）")]),_._v(" "),t("ul",[t("li",[_._v("多路复用，为多路复用设立了请求优先级。")]),_._v(" "),t("li",[_._v("对header部分进行了压缩。")]),_._v(" "),t("li",[_._v("引入了HTTPS加密传输，"),t("code",[_._v("强制使用SSL/TLS加密传输")]),_._v("。")]),_._v(" "),t("li",[_._v("客户端可以在缓存中取到之前请求的内容。")])])]),_._v(" "),t("li",[t("p",[_._v("http 2.0")]),_._v(" "),t("p",[_._v("支持明文传输，增加了"),t("code",[_._v("多路复用、报头压缩、二进制格式传输、可主动将响应推送到客户端")])])]),_._v(" "),t("li",[t("p",[_._v("http 3.0")]),_._v(" "),t("p",[_._v("基于UDP的QUIC协议，"),t("code",[_._v("阻塞问题解决")]),_._v("的更彻底，"),t("code",[_._v("切换网络时保持连接")])])])]),_._v(" "),t("h1",[_._v("二、HTTP1.0 和 HTTP2.0 的区别")]),_._v(" "),t("p",[_._v("具体的解释可见头部的参考文章")]),_._v(" "),t("p",[t("strong",[_._v("http1.0与2.0总的区别就是：")])]),_._v(" "),t("ol",[t("li",[_._v("HTTP/2采用"),t("code",[_._v("二进制格式")]),_._v("而非文本格式")]),_._v(" "),t("li",[_._v("HTTP/2是完全"),t("code",[_._v("多路复用")]),_._v("的，而非有序并阻塞的——只需一个连接即可实现并行")]),_._v(" "),t("li",[_._v("使用"),t("code",[_._v("报头压缩")]),_._v("，HTTP/2降低了开销")]),_._v(" "),t("li",[_._v("HTTP/2让服务器可以将"),t("code",[_._v("响应主动“推送”到客户端缓存")]),_._v("中")])]),_._v(" "),t("p",[t("strong",[_._v("http3.0新的改进是：")])]),_._v(" "),t("ol",[t("li",[_._v("线头阻塞(HOL)问题的解决更为彻底：基于UDP的QUIC协议")]),_._v(" "),t("li",[_._v("切换网络时的连接保持")])]),_._v(" "),t("h1",[_._v("三、HTTP 和 HTTPS 的区别")]),_._v(" "),t("blockquote",[t("p",[_._v("HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。")])]),_._v(" "),t("blockquote",[t("p",[_._v("HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。")])]),_._v(" "),t("p",[_._v("两者主要区别如下：")]),_._v(" "),t("pre",[t("code",[_._v("   1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。\n\n")])]),_._v(" "),t("p",[_._v("2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。")]),_._v(" "),t("p",[_._v("3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。")]),_._v(" "),t("p",[_._v("4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。")]),_._v(" "),t("h1",[_._v("四、HTTPS是如何保证安全的？")]),_._v(" "),t("p",[_._v("参考文章："),t("a",{attrs:{href:"https://www.jianshu.com/p/551d05b0cbee"}},[_._v("https://www.jianshu.com/p/551d05b0cbee")])]),_._v(" "),t("blockquote",[t("p",[_._v("HTTPS就是安全增强版的HTTP，是HTTP协议与加密协议SSL的结合，使HTTP的协议数据在传输过程中更加安全。")])]),_._v(" "),t("p",[_._v("HTTPS将HTTP协议数据包放到SSL/TSL层加密后，在TCP/IP层组成IP数据报去传输，以此保证传输数据的安全；而对于接收端，在SSL/TSL将接收的数据包解密之后，将数据传给HTTP协议层，就是普通的HTTP数据。")]),_._v(" "),t("h3",[_._v("SSL加密方式")]),_._v(" "),t("p",[_._v("总结："),t("strong",[t("code",[_._v("非对称加密+对称加密+CA认证结合")]),_._v("（")]),_._v(" 首先通过非对称加密传输key（对称加密的密钥），然后再对称加密传输数据，同时基于CA认证确保网站的真实安全性）")]),_._v(" "),t("p",[_._v("具体实现方式：")]),_._v(" "),t("p",[t("strong",[_._v("对称加密和非对称加密")])]),_._v(" "),t("p",[_._v("对称加密就是将你要传输的内容用一个密钥加密起来，发送方和都要知道这个密钥，用它来加密解密。但使用对称加密需要给对方传这个密钥，在互联网上传输这个密钥很容易被截取。所以就有了非对称加密，这种加密指的是可以生成一对密钥 (k1, k2)。凡是 k1 加密的数据，k1 自身不能解密，而需要 k2 才能解密；凡是 k2 加密的数据，k2 不能解密，需要 k1 才能解密。")]),_._v(" "),t("p",[t("strong",[_._v("SSL/TLS协议的做法是把这两者结合：")])]),_._v(" "),t("ol",[t("li",[_._v("假如A与B要传输信息，那么A可以使用非对称加密生成一对密钥 (k1, k2)，然后将k1发给B, k2自己保留;")]),_._v(" "),t("li",[_._v("B收到k1后先自己使用对称加密生成一个key, 然后使用k1将这个key加密传给A；")]),_._v(" "),t("li",[_._v("A收到密文后使用k2将其解密，至此，A和B已经完成了key的传输，之后他们就可以使用这个key按对称加密的方式传输信息。")])]),_._v(" "),t("p",[_._v("因为在传输过程中只暴露了k1,要解密需要知道k2,所以就算有人窃取到传输的信息，也无法解密。")]),_._v(" "),t("p",[t("strong",[_._v("CA避免“中间人攻击”")])]),_._v(" "),t("p",[_._v("中间人攻击，指的是它分别欺骗A和B,让对方误以为它是A(或者B),这样它就可以自己定义一个key,然后欺骗A和B,让他们误以为已经完成了key的传输，然后使用这个key来传输信息。为了防止这种攻击，又引入了一个叫 CA的东西。CA（Certificate Authority） 是一些非常权威的专门用于认证一个网站合法性的组织。这样A和B在传输密钥的时候就可以通过CA来判断对方是否合法，这样“中间人攻击”也就无法实施。")]),_._v(" "),t("h1",[_._v("五、服务器推送到底是什么？")]),_._v(" "),t("p",[_._v("服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。比如以前请求一个index.html,返回一个index.html。现在可以请求一个index.html，把他对应的js都一起返回。")])])}]},T=t("VU/8")(null,e,!1,null,null,null);v.default=T.exports},MnNB:function(_,v,t){_.exports=t("M9a/")}});
//# sourceMappingURL=41.80b55362aa00b682f434.js.map