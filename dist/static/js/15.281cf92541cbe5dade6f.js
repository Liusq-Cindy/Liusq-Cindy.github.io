webpackJsonp([15],{"7MBN":function(s,t,e){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var v={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("section",[e("p",[s._v("参考地址：")]),s._v(" "),e("p",[e("a",{attrs:{href:"https://www.cnblogs.com/chenwenhao/p/11258895.html#_label17"}},[s._v("https://www.cnblogs.com/chenwenhao/p/11258895.html#_label17")])]),s._v(" "),e("p",[s._v("此处介绍vue的一些原理：双向绑定原理、响应式原理等等")]),s._v(" "),e("ol",[e("li",[e("strong",[e("a",{attrs:{href:"https://www.notion.so/Vue-d3d43149aff64337a35deb2810810e1b"}},[s._v("vue的双向绑定原理")])])]),s._v(" "),e("li",[e("a",{attrs:{href:"https://www.notion.so/Vue-d3d43149aff64337a35deb2810810e1b"}},[s._v("如何理解V"),e("strong",[s._v("ue组件中的响应式系统?")])])]),s._v(" "),e("li",[e("strong",[e("a",{attrs:{href:"https://www.notion.so/Vue-d3d43149aff64337a35deb2810810e1b"}},[s._v("虚拟 DOM 实现原理")])])]),s._v(" "),e("li",[e("strong",[e("a",{attrs:{href:"https://www.notion.so/Vue-d3d43149aff64337a35deb2810810e1b"}},[s._v("v-model的原理")])])]),s._v(" "),e("li",[e("a",{attrs:{href:"https://www.notion.so/Vue-d3d43149aff64337a35deb2810810e1b"}},[s._v("什么是MVVM")])]),s._v(" "),e("li",[e("a",{attrs:{href:"https://www.notion.so/Vue-d3d43149aff64337a35deb2810810e1b"}},[s._v("vue组件和根实例的关系")])])]),s._v(" "),e("h1",[s._v("一、Vue的双向绑定原理")]),s._v(" "),e("p",[s._v("mvvm 双向绑定，采用"),e("code",[s._v("数据劫持")]),s._v("结合"),e("code",[s._v("发布者-订阅者模式")]),s._v("的方式，通过 "),e("code",[s._v("Object.defineProperty()")]),s._v(" 来劫持各个属性的 "),e("code",[s._v("setter、getter")]),s._v("，在数据变动时发布消息给订阅者，触发相应的监听回调。")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3b28e0c4-529a-4281-9e47-6a25560389c4/Untitled.png",alt:"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3b28e0c4-529a-4281-9e47-6a25560389c4/Untitled.png"}})]),s._v(" "),e("p",[e("strong",[s._v("几个要点：")])]),s._v(" "),e("p",[s._v("1、实现一个数据监听器 Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者")]),s._v(" "),e("p",[s._v("2、实现一个指令解析器 Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数")]),s._v(" "),e("p",[s._v("3、实现一个 Watcher，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图")]),s._v(" "),e("p",[s._v("4、mvvm 入口函数，整合以上三者")]),s._v(" "),e("p",[e("strong",[s._v("具体步骤：")])]),s._v(" "),e("ol",[e("li",[s._v("需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化")]),s._v(" "),e("li",[s._v("compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图")]),s._v(" "),e("li",[s._v("Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:\n"),e("ul",[e("li",[s._v("在自身实例化时往属性订阅器(dep)里面添加自己")]),s._v(" "),e("li",[s._v("自身必须有一个 update() 方法")]),s._v(" "),e("li",[s._v("待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。")])])]),s._v(" "),e("li",[s._v("MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过Observer来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据 model 变更的双向绑定效果。")])]),s._v(" "),e("p",[s._v("参考网址：")]),s._v(" "),e("p",[e("a",{attrs:{href:"https://www.pianshen.com/article/72922044501/"}},[s._v("Vue中的响应式数据/数据双向绑定原理 - 程序员大本营")])]),s._v(" "),e("p",[e("a",{attrs:{href:"https://www.jb51.net/article/142950.htm"}},[s._v("Vue实现双向绑定的原理以及响应式数据的方法_vue.js_脚本之家")])]),s._v(" "),e("h1",[s._v("二、如何理解V"),e("strong",[s._v("ue组件中的响应式系统?")])]),s._v(" "),e("p",[e("img",{attrs:{src:"https://img2018.cnblogs.com/blog/1062623/201908/1062623-20190808112924933-354933996.jpg",alt:"https://img2018.cnblogs.com/blog/1062623/201908/1062623-20190808112924933-354933996.jpg"}})]),s._v(" "),e("p",[s._v("响应式系统简述:")]),s._v(" "),e("ul",[e("li",[s._v("任何一个 Vue Component 都有一个与之对应的 Watcher 实例")]),s._v(" "),e("li",[s._v("Vue 的 data 上的属性会被添加 getter 和 setter 属性")]),s._v(" "),e("li",[s._v("当 Vue Component render 函数被执行的时候, data 上会被 触碰(touch), 即被读, getter 方法会被调用, 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集)")]),s._v(" "),e("li",[s._v("data 被改动时（主要是用户操作）, 即被写, setter 方法会被调用, 此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新")])]),s._v(" "),e("h2",[s._v("对象和数组实现响应式的差别")]),s._v(" "),e("p",[s._v("1、对象实现响应式：")]),s._v(" "),e("p",[s._v("是在初始化的时候利用definePrototype的定义set和get过滤器，在进行组件模板编译时实现water的监听搜集依赖项，当数据发生变化时在set中通过调用dep.notify进行发布通知，实现视图的更新。")]),s._v(" "),e("p",[s._v("2、数组实现响应式：")]),s._v(" "),e("p",[s._v("对于数组则是通过继承重写数组的方法splice、pop、push、shift、unshift、sort、reverse、等可以修改原数组的方式实现响应式的，但是通过length以及直接利用item[index]方式修改数组是不能实现响应式的改变dom（这种两种方式涉及到数组的内部实现）。在数据更新后为了避免过于频繁的进行dom的操作，在vue中会将更新的dom进行批量操作，而不是直接有数据更新就刷新dom，vue将需要更新的dom压入异步队列记性批量操作，提高性能。")]),s._v(" "),e("h1",[s._v("三、"),e("strong",[s._v("虚拟 DOM 实现原理")])]),s._v(" "),e("ul",[e("li",[s._v("虚拟DOM本质上是JavaScript对象,是对真实DOM的抽象")]),s._v(" "),e("li",[s._v("状态变更时，记录新树和旧树的差异")]),s._v(" "),e("li",[s._v("最后把差异更新到真正的dom中")])]),s._v(" "),e("blockquote",[e("p",[s._v("详细实现见 面试官: "),e("a",{attrs:{href:"https://user-gold-cdn.xitu.io/2019/8/1/16c49afec13e0416"}},[s._v("你对虚拟DOM原理的理解?")])])]),s._v(" "),e("h3",[e("strong",[s._v("既然 Vue 通过数据劫持可以精准探测数据变化,为什么还需要虚拟 DOM 进行 diff 检测差异?")])]),s._v(" "),e("p",[s._v("考点: Vue 的变化侦测原理前置知识: 依赖收集、虚拟 DOM、响应式系统现代前端框架有两种方式侦测变化，一种是pull，一种是push")]),s._v(" "),e("p",[s._v("pull: 其代表为React，我们可以回忆一下React是如何侦测到变化的,我们通常会用setStateAPI显式更新，然后React会进行一层层的Virtual Dom Diff操作找出差异，然后Patch到DOM上，React从一开始就不知道到底是哪发生了变化，只是知道「有变化了」，然后再进行比较暴力的Diff操作查找「哪发生变化了」，另外一个代表就是Angular的脏检查操作。")]),s._v(" "),e("p",[s._v("push: Vue的响应式系统则是push的代表，当Vue程序初始化的时候就会对数据data进行依赖的收集，一但数据发生变化,响应式系统就会立刻得知。因此Vue是一开始就知道是「在哪发生变化了」，但是这又会产生一个问题，如果你熟悉Vue的响应式系统就知道，通常一个绑定一个数据就需要一个Watcher，一但我们的绑定细粒度过高就会产生大量的Watcher，这会带来内存以及依赖追踪的开销，而细粒度过低会无法精准侦测变化,因此Vue的设计是选择中等细粒度的方案,在组件级别进行push侦测的方式,也就是那套响应式系统,通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行Virtual Dom Diff获取更加具体的差异，而Virtual Dom Diff则是pull操作，Vue是push+pull结合的方式进行变化侦测的。")]),s._v(" "),e("h1",[s._v("四**、v-model 的原理？**")]),s._v(" "),e("p",[s._v("我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 "),e("strong",[s._v("v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件")]),s._v("：")]),s._v(" "),e("ul",[e("li",[s._v("text 和 textarea 元素使用 value 属性和 input 事件；")]),s._v(" "),e("li",[s._v("checkbox 和 radio 使用 checked 属性和 change 事件；")]),s._v(" "),e("li",[s._v("select 字段将 value 作为 prop 并将 change 作为事件。")])]),s._v(" "),e("p",[s._v("以 input 表单元素为例：")]),s._v(" "),e("pre",[e("code",{staticClass:"language-jsx"},[s._v("<input v-model="),e("span",{staticClass:"hljs-string"},[s._v("'something'")]),s._v(">\n相当于\n<input v-bind:value="),e("span",{staticClass:"hljs-string"},[s._v('"something"')]),s._v(" v-on:input="),e("span",{staticClass:"hljs-string"},[s._v('"something = $event.target.value"')]),s._v(">\n\n")])]),s._v(" "),e("p",[s._v("如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：")]),s._v(" "),e("pre",[e("code",{staticClass:"language-jsx"},[s._v("父组件：\n<ModelChild v-model="),e("span",{staticClass:"hljs-string"},[s._v('"message"')]),s._v("><"),e("span",{staticClass:"hljs-regexp"},[s._v("/ModelChild>\n子组件：\n<div>"),e("span",[s._v("{{")]),s._v("value"),e("span",[s._v("}}")]),s._v("</")]),s._v("div>\n \nprops:{\n    "),e("span",{staticClass:"hljs-attr"},[s._v("value")]),s._v(": "),e("span",{staticClass:"hljs-built_in"},[s._v("String")]),s._v("\n},\n"),e("span",{staticClass:"hljs-attr"},[s._v("methods")]),s._v(": {\n  test1(){\n     "),e("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".$emit("),e("span",{staticClass:"hljs-string"},[s._v("'input'")]),s._v(", "),e("span",{staticClass:"hljs-string"},[s._v("'小红'")]),s._v(")\n  },\n},\n")])]),s._v(" "),e("h1",[s._v("五、"),e("strong",[s._v("什么是 MVVM？")])]),s._v(" "),e("p",[s._v("Model–View–ViewModel （MVVM） 是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表")]),s._v(" "),e("p",[s._v("MVVM 源自于经典的 Model–View–Controller（MVC）模式 ，MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图所示：")]),s._v(" "),e("p",[e("a",{attrs:{href:"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzIwY2YzMTM3ZGIyZjE3NTA4NjkzYTNmOGExZDY0NjUwLnBuZw?x-oss-process=image/format,png"}},[s._v("https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzIwY2YzMTM3ZGIyZjE3NTA4NjkzYTNmOGExZDY0NjUwLnBuZw?x-oss-process=image/format,png")])]),s._v(" "),e("p",[e("strong",[s._v("（1）View 层")])]),s._v(" "),e("p",[s._v("View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。")]),s._v(" "),e("p",[e("strong",[s._v("（2）Model 层")])]),s._v(" "),e("p",[s._v("Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。")]),s._v(" "),e("p",[e("strong",[s._v("（3）ViewModel 层")])]),s._v(" "),e("p",[s._v("ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。")]),s._v(" "),e("p",[s._v("需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。")]),s._v(" "),e("p",[s._v("MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。")]),s._v(" "),e("p",[s._v("这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。")]),s._v(" "),e("p",[s._v("我们以下通过一个 Vue 实例来说明 MVVM 的具体实现，有 Vue 开发经验的同学应该一目了然：")]),s._v(" "),e("p",[e("strong",[s._v("（1）View 层")])]),s._v(" "),e("pre",[e("code",{staticClass:"language-jsx"},[s._v("\n<div id="),e("span",{staticClass:"hljs-string"},[s._v('"app"')]),s._v(">\n    "),e("span",{staticClass:"xml"},[e("span",{staticClass:"hljs-tag"},[s._v("<"),e("span",{staticClass:"hljs-name"},[s._v("p")]),s._v(">")]),e("span",[s._v("{{")]),s._v("message"),e("span",[s._v("}}")]),e("span",{staticClass:"hljs-tag"},[s._v("</"),e("span",{staticClass:"hljs-name"},[s._v("p")]),s._v(">")])]),s._v("\n    "),e("span",{staticClass:"xml"},[e("span",{staticClass:"hljs-tag"},[s._v("<"),e("span",{staticClass:"hljs-name"},[s._v("button")]),s._v(" "),e("span",{staticClass:"hljs-attr"},[s._v("v-on:click")]),s._v("="),e("span",{staticClass:"hljs-string"},[s._v('"showMessage()"')]),s._v(">")]),s._v("Click me"),e("span",{staticClass:"hljs-tag"},[s._v("</"),e("span",{staticClass:"hljs-name"},[s._v("button")]),s._v(">")])]),s._v("\n<"),e("span",{staticClass:"hljs-regexp"},[s._v("/div>\n")])])]),s._v(" "),e("p",[e("strong",[s._v("（2）ViewModel 层")])]),s._v(" "),e("pre",[e("code",{staticClass:"language-jsx"},[e("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" app = "),e("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" Vue({\n    "),e("span",{staticClass:"hljs-attr"},[s._v("el")]),s._v(": "),e("span",{staticClass:"hljs-string"},[s._v("'#app'")]),s._v(",\n    "),e("span",{staticClass:"hljs-attr"},[s._v("data")]),s._v(": {"),e("span",{staticClass:"hljs-comment"},[s._v("// 用于描述视图状态")]),s._v("\n        "),e("span",{staticClass:"hljs-attr"},[s._v("message")]),s._v(": "),e("span",{staticClass:"hljs-string"},[s._v("'Hello Vue!'")]),s._v(",\n    },\n    "),e("span",{staticClass:"hljs-attr"},[s._v("methods")]),s._v(": {"),e("span",{staticClass:"hljs-comment"},[s._v("// 用于描述视图行为")]),s._v("\n        showMessage(){\n            "),e("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" vm = "),e("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(";\n            alert(vm.message);\n        }\n    },\n    created(){\n        "),e("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" vm = "),e("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(";\n"),e("span",{staticClass:"hljs-comment"},[s._v("// Ajax 获取 Model 层的数据")]),s._v("\n        ajax({\n            "),e("span",{staticClass:"hljs-attr"},[s._v("url")]),s._v(": "),e("span",{staticClass:"hljs-string"},[s._v("'/your/server/data/api'")]),s._v(",\n            success(res){\n                vm.message = res;\n            }\n        });\n    }\n")])]),s._v(" "),e("p",[s._v("（3） Model 层")]),s._v(" "),e("pre",[e("code",{staticClass:"language-jsx"},[s._v("{\n    "),e("span",{staticClass:"hljs-string"},[s._v('"url"')]),s._v(": "),e("span",{staticClass:"hljs-string"},[s._v('"/your/server/data/api"')]),s._v(",\n    "),e("span",{staticClass:"hljs-string"},[s._v('"res"')]),s._v(": {\n        "),e("span",{staticClass:"hljs-string"},[s._v('"success"')]),s._v(": "),e("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(",\n        "),e("span",{staticClass:"hljs-string"},[s._v('"name"')]),s._v(": "),e("span",{staticClass:"hljs-string"},[s._v('"IoveC"')]),s._v(",\n        "),e("span",{staticClass:"hljs-string"},[s._v('"domain"')]),s._v(": "),e("span",{staticClass:"hljs-string"},[s._v('"www.cnblogs.com"')]),s._v("\n    }\n\n")])]),s._v(" "),e("h1",[s._v("六、vue组件和根实例的关系")]),s._v(" "),e("p",[s._v("理解vue的实例和vue的组件的关系，参考下文：")]),s._v(" "),e("p",[e("a",{attrs:{href:"https://blog.csdn.net/qq_35139897/article/details/103051490"}},[s._v("vue-cli构建的项目，vue组件和根实例的关系_qq_35139897的博客-CSDN博客")])]),s._v(" "),e("blockquote",[e("p",[s._v("一般来说，我们的vue项目，一个项目，就是一个vue的实例。我们所说的vue组件，只是vue component的实例")])]),s._v(" "),e("p",[s._v("1.整个项目是一个vue的实例")]),s._v(" "),e("p",[s._v("2.每个页面或者每个组件是一个vue component的实例")]),s._v(" "),e("blockquote",[e("p",[s._v("从根目录可以看到，我们项目都有有个index.html文件，里面一个div的id为‘app’，在main.js文件中，会引入vue，vue实例会挂载到app这个标签内，以及router、vuex等插件。main.js中初始化new Vue中会导入顶级单文件组件App.vue，App.vue中会通过路由控制来引入其他的各种单文件组件")])]),s._v(" "),e("p",[s._v("如果我们使用vue-cli来初始化一个项目，以上就不用自己去构建，脚手架会帮我们搭好，还会引入webpack等打包工具。")])])}]},a=e("VU/8")(null,v,!1,null,null,null);t.default=a.exports},CTKF:function(s,t,e){s.exports=e("7MBN")}});
//# sourceMappingURL=15.281cf92541cbe5dade6f.js.map