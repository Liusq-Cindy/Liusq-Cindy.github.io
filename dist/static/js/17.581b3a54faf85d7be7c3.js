webpackJsonp([17],{"+Lqv":function(t,e,s){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var v={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("section",[s("p",[t._v("参考文章：")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.cnblogs.com/vickylinj/p/13529926.html"}},[t._v("VUE源码相关面试题汇总")])]),t._v(" "),s("blockquote",[s("p",[t._v("Vue的源码有很多，暂时不能完全掌握，但其中每一个小的知识点和设计思维值得我们学习和研究，这里针对一些小的知识点谈谈Vue的源码中具体是如何实现的：")])]),t._v(" "),s("h3",[t._v("常见问题列表：")]),t._v(" "),s("ol",[s("li",[s("strong",[s("a",{attrs:{href:"https://www.notion.so/Vue-c2fbed79fefb4efa855c3f2c7b2ceb4f"}},[t._v("谈一下你对MVC和MVVM原理的理解")])])]),t._v(" "),s("li",[s("strong",[s("a",{attrs:{href:"https://www.notion.so/Vue-c2fbed79fefb4efa855c3f2c7b2ceb4f"}},[t._v("请说一下响应式数据的原理（Vue2和Vue3）")])])]),t._v(" "),s("li",[s("strong",[s("a",{attrs:{href:"https://www.notion.so/Vue-c2fbed79fefb4efa855c3f2c7b2ceb4f"}},[t._v("vue中时如何检测数组变化的：使用了函数劫持的方式，重写了数组方法")])])]),t._v(" "),s("li",[s("strong",[s("a",{attrs:{href:"https://www.notion.so/Vue-c2fbed79fefb4efa855c3f2c7b2ceb4f"}},[t._v("nextTick 的作用和实现原理？")])])]),t._v(" "),s("li",[s("strong",[s("a",{attrs:{href:"https://www.notion.so/Vue-c2fbed79fefb4efa855c3f2c7b2ceb4f"}},[t._v("Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？")])])]),t._v(" "),s("li",[s("strong",[s("a",{attrs:{href:"https://www.notion.so/Vue-c2fbed79fefb4efa855c3f2c7b2ceb4f"}},[t._v("computed的作用和实现原理？")])])]),t._v(" "),s("li",[s("strong",[s("a",{attrs:{href:"https://www.notion.so/Vue-c2fbed79fefb4efa855c3f2c7b2ceb4f"}},[t._v("watch中的deep:true是如何实现的？")])])]),t._v(" "),s("li",[s("strong",[s("a",{attrs:{href:"https://www.notion.so/Vue-c2fbed79fefb4efa855c3f2c7b2ceb4f"}},[t._v("vue中模板编译原理")])])]),t._v(" "),s("li",[s("strong",[s("a",{attrs:{href:"https://www.notion.so/Vue-c2fbed79fefb4efa855c3f2c7b2ceb4f"}},[t._v("简述vue中diff算法原理")])])]),t._v(" "),s("li",[s("strong",[s("a",{attrs:{href:"https://www.notion.so/Vue-c2fbed79fefb4efa855c3f2c7b2ceb4f"}},[t._v("v-for中为什么要用key？")])])]),t._v(" "),s("li",[s("strong",[s("a",{attrs:{href:"https://www.notion.so/Vue-c2fbed79fefb4efa855c3f2c7b2ceb4f"}},[t._v("组件中的data为什么是个函数？")])])]),t._v(" "),s("li",[s("strong",[s("a",{attrs:{href:"https://www.notion.so/Vue-c2fbed79fefb4efa855c3f2c7b2ceb4f"}},[t._v("Vue中事件绑定的原理")])])]),t._v(" "),s("li",[s("strong",[s("a",{attrs:{href:"https://www.notion.so/Vue-c2fbed79fefb4efa855c3f2c7b2ceb4f"}},[t._v("v-model的实现原理及如何自定义v-model？")])])])]),t._v(" "),s("h1",[t._v("常见问题")]),t._v(" "),s("h1",[t._v("1、谈一下对MVC和MVVM原理的理解")]),t._v(" "),s("p",[t._v("详细解释的文章："),s("a",{attrs:{href:"https://blog.csdn.net/qq_42068550/article/details/89480350"}},[t._v("https://blog.csdn.net/qq_42068550/article/details/89480350")])]),t._v(" "),s("p",[s("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html"}},[t._v("http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html")])]),t._v(" "),s("p",[s("a",{attrs:{href:"https://blog.csdn.net/qq_29722281/article/details/99717680"}},[t._v("https://blog.csdn.net/qq_29722281/article/details/99717680")])]),t._v(" "),s("h3",[t._v("介绍")]),t._v(" "),s("p",[t._v("MVC、MVP和MVVM是三种软件设计典范，也基于此做了很多前端架构模式。他们当中的M和V含义是相同的，表示model数据层和View视图层，差别在于中间的纽带部分，即：C-controller，P-Presenter，VM-viewmodel。")]),t._v(" "),s("p",[t._v("MVP和MVVM是基于MVC模式逐步演变而来。")]),t._v(" "),s("h3",[t._v("MVC")]),t._v(" "),s("p",[t._v("全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写")]),t._v(" "),s("p",[t._v("MVC：数据流是单向的，view——>Controller——>model—->view")]),t._v(" "),s("ul",[s("li",[t._v("用户对View的操作交给了Controller处理")]),t._v(" "),s("li",[t._v("在Controller中响应View的事件调用Model的接口对数据进行操作")]),t._v(" "),s("li",[t._v("一旦Model发生变化便通知相关视图进行更新。")])]),t._v(" "),s("p",[t._v("前端简单理解：将html部分视作View，js处理逻辑部分视作controller，监听用户在view上的事件，处理之后，通过model处理数据（如ajax请求后端服务），然后将model的数据再同步给view，视图层展示出来。")]),t._v(" "),s("p",[t._v("痛点：大量频繁的DOM操作、开发者需要主动更新model变化并同步到view非常繁琐")]),t._v(" "),s("h3",[t._v("MVP")]),t._v(" "),s("p",[t._v("全由中间层presentor来间接传递，处理逻辑，但并不是自动同步的。")]),t._v(" "),s("p",[t._v("数据流： View<—>Presentor<—>model")]),t._v(" "),s("ol",[s("li",[t._v("双向通信")]),t._v(" "),s("li",[t._v("View 与 Model 通过 Presenter "),s("strong",[t._v("间接传递")])]),t._v(" "),s("li",[t._v('View 很薄不部署任何业务逻辑，称为"被动视图"（Passive View），即没有任何主动性，而 Presenter很厚，部署所有逻辑')])]),t._v(" "),s("h3",[t._v("MVVM")]),t._v(" "),s("p",[t._v("MVVM与MVC最大的区别就是：实现了View和Model的"),s("strong",[t._v("自动同步。")])]),t._v(" "),s("p",[t._v("MVVM：数据驱动数据流是双向的，model←→viwModel<—>view")]),t._v(" "),s("p",[t._v("不需要用户调用选择器手动操作dom，而是将数据绑定到viewModel上，会将数据自动渲染到页面中。如果视图变化，会通知viewModel层更新数据。")]),t._v(" "),s("p",[t._v("前端理解：")]),t._v(" "),s("p",[t._v("Vue框架是典型的MVVM模式：")]),t._v(" "),s("ul",[s("li",[t._v("html部分相当于View层，View通过模板语法将数据渲染进DOM元素，当ViewModel对Model进行更新时，通过数据绑定更新到View。")]),t._v(" "),s("li",[t._v("data相当于Model层，而ViewModel层的核心是Vue中的"),s("strong",[t._v("双向数据绑定")]),t._v("，即Model变化时VIew可以实时更新，View变化也能让Model发生变化。")])]),t._v(" "),s("h3",[t._v("题外话")]),t._v(" "),s("p",[t._v("关于vue\\react是否是MVVM模式有很多的讨论，设计模式只是一种理念，为了激发大家做框架设计的思维，实际VUE中也会有直接操作dom，如$refs的使用，并不是完全符合MVVM的不操作DOM的要求，但整体上我们可以这么来理解他的设计，尤其是他的双向数据绑定这一块，是非常核心的优秀设计。")]),t._v(" "),s("h1",[t._v("2、"),s("strong",[t._v("请说一下响应式数据的原理（Vue2和Vue3）")])]),t._v(" "),s("p",[t._v("demo演示可查看文章："),s("a",{attrs:{href:"https://blog.csdn.net/qq_43378800/article/details/100086039"}},[t._v("https://blog.csdn.net/qq_43378800/article/details/100086039")])]),t._v(" "),s("h3",[s("strong",[t._v("vue2——核心点：Object.defineProperty —— 修改每一个属性")])]),t._v(" "),s("p",[t._v("Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。")]),t._v(" "),s("p",[t._v("默认Vue在初始化数据时，会给data中的属性使用Object.defineProperty，在获取和设置的进行拦截，重新定义所有属性。当页面取到对应属性时，会进行依赖收集（收集当前组件的watcher）。如果属性发生变化会通知相关依赖进行更新操作。**依赖收集、派发更新的作用：**如果没有这项操作，每个数据更新就会去渲染页面，极大的消耗性能。加了这项操作，去监听相关数据的改变，添加到队列里，当所有改变完事儿之后，一起进行渲染")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5fc93016-66f9-4304-bf24-f5fc90a8b0ea/Untitled.png",alt:"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5fc93016-66f9-4304-bf24-f5fc90a8b0ea/Untitled.png"}})]),t._v(" "),s("p",[t._v("从图中可以看出，")]),t._v(" "),s("p",[s("strong",[t._v("当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行扫描和解析，初始化视图，并订阅 Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep)，初始化完毕。　　当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。")])]),t._v(" "),s("p",[s("strong",[t._v("defineProperty")]),t._v("只能对属性进行数据劫持，不能对整个对象进行劫持**，**对于数组和对象，Vue是通过通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。")]),t._v(" "),s("h3",[s("strong",[t._v("vue3——核心点：proxy（代理）—— 直接处理对象")])]),t._v(" "),s("p",[t._v("基于es6的"),s("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/proxy"}},[t._v("Proxy代理器")]),t._v("来实现双向数据绑定，通过get和set方法监听数据变化。")]),t._v(" "),s("p",[t._v("defineProperty只能监听到自己所写的属性,其他的无法监听,但是proxy直接可以劫持整个对象，可以监听到所有写的属性。等于Object.defineProperty的超级加强版。")]),t._v(" "),s("pre",[s("code",{staticClass:"language-jsx"},[t._v("<script>\n    "),s("span",{staticClass:"hljs-keyword"},[t._v("var")]),t._v(" data={}\n\n    "),s("span",{staticClass:"hljs-keyword"},[t._v("var")]),t._v(" dataProxy="),s("span",{staticClass:"hljs-keyword"},[t._v("new")]),t._v(" "),s("span",{staticClass:"hljs-built_in"},[t._v("Proxy")]),t._v("(data,{ "),s("span",{staticClass:"hljs-comment"},[t._v("// es6的新特性 proxy代理器，这里可用于监听这个data的变化")]),t._v("\n      "),s("span",{staticClass:"hljs-keyword"},[t._v("get")]),t._v("(obj,prop) {\n        "),s("span",{staticClass:"hljs-built_in"},[t._v("console")]),t._v(".log("),s("span",{staticClass:"hljs-string"},[t._v("'调用了'")]),t._v(")\n      },\n\n      "),s("span",{staticClass:"hljs-keyword"},[t._v("set")]),t._v("(obj,prop,value) {\n        "),s("span",{staticClass:"hljs-built_in"},[t._v("console")]),t._v(".log("),s("span",{staticClass:"hljs-string"},[t._v("'赋值了'")]),t._v(")\n      }\n    })\n\n    dataProxy.name="),s("span",{staticClass:"hljs-string"},[t._v("'jack'")]),t._v("\n    "),s("span",{staticClass:"hljs-built_in"},[t._v("console")]),t._v(".log(dataProxy.name)\n  <"),s("span",{staticClass:"hljs-regexp"},[t._v("/script>\n")])])]),t._v(" "),s("p",[s("strong",[t._v("解决了vue2中的处理对象递归、处理数组麻烦的问题")])]),t._v(" "),s("p",[s("strong",[t._v("原理：")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8cdd2ef5-dd1e-4007-9ae2-0356b7a980ca/Untitled.png",alt:"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8cdd2ef5-dd1e-4007-9ae2-0356b7a980ca/Untitled.png"}})]),t._v(" "),s("p",[t._v("更多实现可参考文章：")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://vue3js.cn/es6/#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8proxy%E9%87%8D%E6%9E%84"}},[t._v("ES6的代理模式 | Proxy | Vue3")])]),t._v(" "),s("h1",[t._v("3、"),s("strong",[t._v("vue中时如何检测数组变化的")])]),t._v(" "),s("p",[t._v("vue2中的defineProperty是监听不了数组的，因此在底层，设计者通过"),s("code",[t._v("遍历数组，迭代对象")]),t._v("的方式，data中的数组，进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次进行监控。")]),t._v(" "),s("p",[t._v("Object.create()，保存原有原型")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/99b5d41f-259c-4b7e-b61b-3c06fd9599aa/Untitled.png",alt:"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/99b5d41f-259c-4b7e-b61b-3c06fd9599aa/Untitled.png"}})]),t._v(" "),s("h1",[t._v("4、"),s("strong",[t._v("nextTick 的作用和实现原理？")])]),t._v(" "),s("p",[t._v("参考地址："),s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/174396758"}},[t._v("https://zhuanlan.zhihu.com/p/174396758")])]),t._v(" "),s("ol",[s("li",[t._v("Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按"),s("strong",[t._v("一定的策略")]),t._v("（会监听数据变化，并"),s("strong",[t._v("缓存在同一事件循环")]),t._v("中，等同一数据循环中的所有数据变化完成之后，再统一进行视图更新）进行 "),s("code",[t._v("DOM 的更新")]),t._v("，以保证性能（即vue当中的DOM更新是异步执行的）。")]),t._v(" "),s("li",[t._v("因此我们在修改了数据之后，视图不会立刻更新，如果这时候要获取更新后的DOM，是拿不到的，为了确保得到，设置了Vue.nextTick()方法")]),t._v(" "),s("li",[t._v("Vue.nextTick()方法是在下次DOM更新循环结束之后执行"),s("strong",[t._v("延迟回调")]),t._v("。在修改数据之后立即使用这个方法，获取更新后的DOM。")]),t._v(" "),s("li",[t._v("每次调用"),s("code",[t._v("Vue.nextTick")]),t._v("时会执行：")])]),t._v(" "),s("ul",[s("li",[t._v("把传入的回调函数"),s("code",[t._v("cb")]),t._v("压入"),s("code",[t._v("callbacks")]),t._v("数组")]),t._v(" "),s("li",[t._v("执行"),s("code",[t._v("timerFunc")]),t._v("函数，延迟调用 "),s("code",[t._v("flushCallbacks")]),t._v(" 函数")]),t._v(" "),s("li",[t._v("遍历执行 "),s("code",[t._v("callbacks")]),t._v(" 数组中的所有函数")])]),t._v(" "),s("p",[t._v("这里的 "),s("code",[t._v("callbacks")]),t._v(" 没有直接在 "),s("code",[t._v("nextTick")]),t._v(" 中执行回调函数的原因是保证在同一个 "),s("code",[t._v("tick")]),t._v(" 内多次执行"),s("code",[t._v("nextTick")]),t._v("，不会开启多个异步任务，而是把这些异步任务都压成一个同步任务，在下一个 "),s("code",[t._v("tick")]),t._v(" 执行完毕。")]),t._v(" "),s("p",[t._v("nextTick主要是使用了宏任务和微任务，定义了一个异步方法。多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列，所以nextTick就是异步方法。")]),t._v(" "),s("p",[t._v("原理：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f3083efa-df2f-45fc-b3ea-10ba5dfb46e0/Untitled.png",alt:"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f3083efa-df2f-45fc-b3ea-10ba5dfb46e0/Untitled.png"}})]),t._v(" "),s("h1",[t._v("5、V"),s("strong",[t._v("ue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？")])]),t._v(" "),s("p",[t._v("受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。")]),t._v(" "),s("p",[t._v("但是 Vue 提供了 Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value) 来实现为对象添加响应式属性，那框架本身是如何实现的呢？")]),t._v(" "),s("p",[t._v("我们查看对应的 Vue 源码：vue/src/core/instance/index.js")]),t._v(" "),s("pre",[s("code",{staticClass:"language-jsx"},[s("span",{staticClass:"hljs-keyword"},[t._v("export")]),t._v(" "),s("span",{staticClass:"hljs-function"},[s("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" "),s("span",{staticClass:"hljs-title"},[t._v("set")]),t._v(" ("),s("span",{staticClass:"hljs-params"},[t._v("target: Array<any> | Object, key: any, val: any")]),t._v("): "),s("span",{staticClass:"hljs-title"},[t._v("any")]),t._v(" ")]),t._v("{\n  "),s("span",{staticClass:"hljs-comment"},[t._v("// target 为数组  ")]),t._v("\n  "),s("span",{staticClass:"hljs-keyword"},[t._v("if")]),t._v(" ("),s("span",{staticClass:"hljs-built_in"},[t._v("Array")]),t._v(".isArray(target) && isValidArrayIndex(key)) {\n    "),s("span",{staticClass:"hljs-comment"},[t._v("// 修改数组的长度, 避免索引>数组长度导致splcie()执行有误")]),t._v("\n    target.length = "),s("span",{staticClass:"hljs-built_in"},[t._v("Math")]),t._v(".max(target.length, key)\n    "),s("span",{staticClass:"hljs-comment"},[t._v("// 利用数组的splice变异方法触发响应式  ")]),t._v("\n    target.splice(key, "),s("span",{staticClass:"hljs-number"},[t._v("1")]),t._v(", val)\n    "),s("span",{staticClass:"hljs-keyword"},[t._v("return")]),t._v(" val\n  }\n  "),s("span",{staticClass:"hljs-comment"},[t._v("// key 已经存在，直接修改属性值  ")]),t._v("\n  "),s("span",{staticClass:"hljs-keyword"},[t._v("if")]),t._v(" (key "),s("span",{staticClass:"hljs-keyword"},[t._v("in")]),t._v(" target && !(key "),s("span",{staticClass:"hljs-keyword"},[t._v("in")]),t._v(" "),s("span",{staticClass:"hljs-built_in"},[t._v("Object")]),t._v(".prototype)) {\n    target[key] = val\n    "),s("span",{staticClass:"hljs-keyword"},[t._v("return")]),t._v(" val\n  }\n  "),s("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" ob = (target: any).__ob__\n  "),s("span",{staticClass:"hljs-comment"},[t._v("// target 本身就不是响应式数据, 直接赋值")]),t._v("\n  "),s("span",{staticClass:"hljs-keyword"},[t._v("if")]),t._v(" (!ob) {\n    target[key] = val\n    "),s("span",{staticClass:"hljs-keyword"},[t._v("return")]),t._v(" val\n  }\n  "),s("span",{staticClass:"hljs-comment"},[t._v("// 对属性进行响应式处理")]),t._v("\n  defineReactive(ob.value, key, val)\n  ob.dep.notify()\n  "),s("span",{staticClass:"hljs-keyword"},[t._v("return")]),t._v(" val\n}\n")])]),t._v(" "),s("p",[t._v("我们阅读以上源码可知，vm.$set 的实现原理是：")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("如果目标是数组，直接使用数组的 splice 方法触发响应式；")])]),t._v(" "),s("li",[t._v("如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是"),s("code",[t._v("通过调用 defineReactive 方法进行响应式处理")]),t._v("（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性"),s("code",[t._v("采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法")]),t._v("）")])]),t._v(" "),s("h1",[t._v("6、"),s("strong",[t._v("computed的作用和实现原理？")])]),t._v(" "),s("p",[t._v("computed计算属性，有两种方式，一种是函数式，一种是声明式，在内部通过get获取改动。因为在模版中放入太多声明式的逻辑会让模板本身过重，所以computed就是用来处理大量复杂的逻辑表达式，然后将结果数据返回给绑定数据的。他"),s("code",[t._v("有缓存性，也就是当依赖的data中的数据没有改变时，不会重新计算数据返回。")])]),t._v(" "),s("h3",[t._v("computed原理是什么：")]),t._v(" "),s("p",[t._v("学习中最常见听到的一句话就是，computed就是一个特殊的getter方法。在代理函数可以结合watcher实现缓存与收集依赖。\n1）计算属性具有缓存性，如何知道计算属性的返回值发生变化呢？\n这其实就是结合了**"),s("code",[t._v("watcher的dirty属性")]),t._v("**来分辨的，当dirty为true时，说明需要重新计算，当为false时，计算属性没有改变，不需要重新计算，直接读取缓存值就好。\n2）模拟一下计算属性内容发生改变后：\n计算属性的watcher和组件内的watcher都会得到通知\n计算属性的watcher将自己的属性dirty设置为true\n下次读取计算属性时，因为dirty为true重新计算一次值\n组件watcher得到通知，从而执行render函数进行重新渲染")]),t._v(" "),s("h3",[t._v("执行过程：")]),t._v(" "),s("p",[t._v("使用watcher读取计算属性\n读取计算属性函数中的数据，定义响应式时，get读取的就是watcher.value\n计算属性和组件watcher同时观察数据的变化\n当数据改变后，计算属性和组件watcher都会收到通知\n组件watcher会重新渲染组件\n计算属性watcher因为数据改变，dirty属性为true,将重新计算\n计算属性计算的结果用于本次渲染，并缓存起来")]),t._v(" "),s("p",[t._v("默认computed也是一个watcher，具备缓存，只有当依赖的属性发生变化才会更新视图。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a3f92999-d9e1-4f25-80d2-2a7973fab8ab/Untitled.png",alt:"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a3f92999-d9e1-4f25-80d2-2a7973fab8ab/Untitled.png"}})]),t._v(" "),s("h3",[t._v("watch和computed的区别是什么？")]),t._v(" "),s("p",[t._v("watch是一种行为，在状态改变之后需要做什么。适用一个数据影响多个数据。\ncomputed就是一种状态，也可以说多种状态初始化后的结果。适用多个数据影响一个数据。\n我认为把，computed与filter作为比较不是更好一些吗？都是用来初始化状态用的。\ncomputed更适用于大量数据计算的结果，并且反复使用，而且不常更新。因为有缓存，大大提升性能。\nfilter适用于少量数据进行初始化处理，计算量不能太大，因为每次渲染都会计算，并且可以频繁更新。")]),t._v(" "),s("h1",[t._v("7、"),s("strong",[t._v("watch中的deep:true是如何实现的？")])]),t._v(" "),s("p",[t._v("当用户指定了watch中的deep属性为true时，如果当时监控的属性是数组类型，会对对象中的每一项进行求值，此时会将当前watcher存入到对应属性的依赖中，这样数组中对象发生变化时也会通知数据更新。")]),t._v(" "),s("p",[t._v("内部原理就是"),s("code",[t._v("递归")]),t._v("，耗费性能 。")]),t._v(" "),s("h1",[t._v("8、"),s("strong",[t._v("vue中模板编译原理")])]),t._v(" "),s("p",[s("strong",[t._v("模板（template）》 ast语法树（抽象语法树）》 codegen方法 ==》render函数 ==》createElement方法 ==》 Virtual Dom（虚拟dom）")])]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("模板转语法树")])]),t._v(" "),s("li",[t._v("模板结合数据，生成抽象语法树，描述html、js语法")]),t._v(" "),s("li",[t._v("语法树生成render函数")]),t._v(" "),s("li",[t._v("生成Virtual Dom(虚拟dom)，描述真实的dom节点")]),t._v(" "),s("li",[t._v("渲染成真实dom")])]),t._v(" "),s("h1",[t._v("9、"),s("strong",[t._v("简述vue中diff算法原理")])]),t._v(" "),s("p",[t._v("Vue中的diff算法进行了优化，只考虑同级不考虑跨级，将时间复杂度从O(n^3)降为O(n)。前端当中，很少会跨层级的移动Dom元素，所以Virtual Dom只会对同一个层级的元素进行对比。")]),t._v(" "),s("p",[s("strong",[t._v("diff算法原理")])]),t._v(" "),s("p",[t._v("1、先同级比较，再比较儿子节点")]),t._v(" "),s("p",[t._v("2、先判断一方有儿子一方没儿子的情况")]),t._v(" "),s("p",[t._v("3、比较都有儿子的情况")]),t._v(" "),s("p",[t._v("4、递归比较子节点vue3中做了优化，只比较动态节点，略过静态节点，极大的提高了效率双指针去确定位置")]),t._v(" "),s("h1",[t._v("10、"),s("strong",[t._v("v-for中为什么要用key？")])]),t._v(" "),s("p",[t._v("解决vue中diff算法结构相同key相同，内容复用的问题，通过key（最好自定义id，不要用索引），明确dom元素，防止复用")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200710143352940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk3MDk4Nw==,size_16,color_FFFFFF,t_70",alt:"https://img-blog.csdnimg.cn/20200710143352940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk3MDk4Nw==,size_16,color_FFFFFF,t_70"}})]),t._v(" "),s("h1",[t._v("11、"),s("strong",[t._v("组件中的data为什么是个函数？")])]),t._v(" "),s("p",[t._v("同一个组件被复用多次，会创建多个实例。这些实例用的是同一个构造函数，如果data是一个对象的话，所有组件共享了同一个对象。为了保证组件的数据独立性，要求每个组件都必须通过data函数返回一个对象作为组件的状态。")]),t._v(" "),s("h1",[t._v("12、"),s("strong",[t._v("Vue中事件绑定的原理")])]),t._v(" "),s("p",[t._v("Vue的事件绑定分为两种：一种是原生的事件绑定，一种是组件的事件绑定")]),t._v(" "),s("p",[t._v("原生dom事件绑定采用的是addEventListener")]),t._v(" "),s("p",[t._v("组件的事件绑定采用的是$on方法")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f3bf7a21-2391-459d-a0be-a6c4252bb7ea/Untitled.png",alt:"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f3bf7a21-2391-459d-a0be-a6c4252bb7ea/Untitled.png"}})]),t._v(" "),s("h1",[t._v("13、"),s("strong",[t._v("v-model的实现原理及如何自定义v-model？")])]),t._v(" "),s("p",[t._v("v-model可以看成是value+input方法的语法糖")])])}]},a=s("VU/8")(null,v,!1,null,null,null);e.default=a.exports},"0rYK":function(t,e,s){t.exports=s("+Lqv")}});
//# sourceMappingURL=17.581b3a54faf85d7be7c3.js.map