webpackJsonp([46],{mm8P:function(s,a,t){s.exports=t("nk7M")},nk7M:function(s,a,t){"use strict";Object.defineProperty(a,"__esModule",{value:!0});var v={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("section",[t("p",[t("strong",[s._v("说明：此处仅罗列了比较常见和基础的ES6新增用法，其他使用细节、注意事项和其他用法须参考官网")])]),s._v(" "),t("p",[t("a",{attrs:{href:"https://es6.ruanyifeng.com/#README"}},[s._v("ES6 入门教程")])]),s._v(" "),t("h1",[t("strong",[s._v("一、let")])]),s._v(" "),t("p",[s._v("1、用来声明变量，用法类似于var,只在其所在的代码块内有效（块级作用域）")]),s._v(" "),t("p",[s._v("2、for循环中用let声明i就很好用，使计数器i只在for循环体内有效，避免冲突")]),s._v(" "),t("p",[s._v("3、不允许重复声明")]),s._v(" "),t("h1",[t("strong",[s._v("二、块级作用域")])]),s._v(" "),t("p",[s._v("1、{ } 允许任意嵌套")]),s._v(" "),t("p",[s._v("2、外层作用域无法读取内层作用域的变量")]),s._v(" "),t("p",[s._v("3、允许在块级作用域之中声明函数，函数声明类似于Var，会提升到全局作用域或函数作用域的头部")]),s._v(" "),t("h1",[t("strong",[s._v("三、const")])]),s._v(" "),t("p",[s._v("1、声明一个只读的常量，一旦声明，常量的值不能改变，保存的只是一个指向实际数据的指针")]),s._v(" "),t("h1",[t("strong",[s._v("四、解构赋值")])]),s._v(" "),t("p",[s._v("1、"),t("strong",[s._v("let [a,b,c] = [1,2,3]")]),s._v(" 可以从数组中提取值，按照对应位置，对变量赋值")]),s._v(" "),t("p",[s._v("2、允许指定默认值")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" [x, y = "),t("span",{staticClass:"hljs-string"},[s._v("'b'")]),s._v("] = ["),t("span",{staticClass:"hljs-string"},[s._v("'a'")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v("]; "),t("span",{staticClass:"hljs-comment"},[s._v("// x='a', y='b'")]),s._v("\n")])]),s._v(" "),t("p",[s._v("3、对象也可以解构赋值，对象的属性没有次序，变量名必须与属性同名，才能取到正确的值")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" { foo, bar } = { "),t("span",{staticClass:"hljs-attr"},[s._v("foo")]),s._v(": "),t("span",{staticClass:"hljs-string"},[s._v('"aaa"')]),s._v(", "),t("span",{staticClass:"hljs-attr"},[s._v("bar")]),s._v(": "),t("span",{staticClass:"hljs-string"},[s._v('"bbb"')]),s._v(" };\nfoo "),t("span",{staticClass:"hljs-comment"},[s._v('// "aaa"')]),s._v("\nbar "),t("span",{staticClass:"hljs-comment"},[s._v('// "bbb"')]),s._v("\n")])]),s._v(" "),t("p",[s._v("如果要不一样的变量名（要换新的名字，则需要加上**：newname**,如下")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" { **foo: baz** } = { "),t("span",{staticClass:"hljs-attr"},[s._v("foo")]),s._v(": "),t("span",{staticClass:"hljs-string"},[s._v("'aaa'")]),s._v(", "),t("span",{staticClass:"hljs-attr"},[s._v("bar")]),s._v(": "),t("span",{staticClass:"hljs-string"},[s._v("'bbb'")]),s._v(" };\nbaz "),t("span",{staticClass:"hljs-comment"},[s._v('// "aaa"')]),s._v("\n")])]),s._v(" "),t("p",[s._v("4、字符串也可以解构赋值，被转换成类似数组的对象")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" [a, b, c, d, e] = "),t("span",{staticClass:"hljs-string"},[s._v("'hello'")]),s._v(";\na "),t("span",{staticClass:"hljs-comment"},[s._v('// "h"')]),s._v("\n")])]),s._v(" "),t("p",[s._v("5、数值和布尔值")]),s._v(" "),t("p",[s._v("解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。")]),s._v(" "),t("p",[s._v("6、常用用途")]),s._v(" "),t("ol",[t("li",[s._v("交换变量值 [x,y] = [y,x]")]),s._v(" "),t("li",[s._v("从函数返回多个值 let[a,b,c] = example()  或对象 let {foo,bar} = example()")]),s._v(" "),t("li",[s._v("提取json对象的数据 let{id,name,data} = jsonData")]),s._v(" "),t("li",[s._v("遍历map结构")])]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" map = "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Map")]),s._v("();\nmap.set("),t("span",{staticClass:"hljs-string"},[s._v("'first'")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'hello'")]),s._v(");\nmap.set("),t("span",{staticClass:"hljs-string"},[s._v("'second'")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'world'")]),s._v(");\n\n"),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" [key, value] "),t("span",{staticClass:"hljs-keyword"},[s._v("of")]),s._v(" map) {\n  "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(key + "),t("span",{staticClass:"hljs-string"},[s._v('" is "')]),s._v(" + value);\n}\n"),t("span",{staticClass:"hljs-comment"},[s._v("// first is hello")]),s._v("\n"),t("span",{staticClass:"hljs-comment"},[s._v("// second is world")]),s._v("\n\n如果只想获取键名，或者只想获取键值，可以写成下面这样。（key和value都可以用别的单词替代）\n\n"),t("span",{staticClass:"hljs-comment"},[s._v("// 获取键名")]),s._v("\n"),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" [key] "),t("span",{staticClass:"hljs-keyword"},[s._v("of")]),s._v(" map) {\n  "),t("span",{staticClass:"hljs-comment"},[s._v("// ...")]),s._v("\n}\n\n"),t("span",{staticClass:"hljs-comment"},[s._v("// 获取键值")]),s._v("\n"),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" [,value] "),t("span",{staticClass:"hljs-keyword"},[s._v("of")]),s._v(" map) {\n  "),t("span",{staticClass:"hljs-comment"},[s._v("// ...")]),s._v("\n}\n")])]),s._v(" "),t("h1",[t("strong",[s._v("五、字符串扩展之模板字符串")])]),s._v(" "),t("p",[s._v("1、和以往的字符串模板不同，不用那么多引号和加号，"),t("code"),s._v("反引号标识，将变量名写在${}中用来嵌入变量")]),s._v(" "),t("p",[s._v("2、还能调用函数 "),t("code",[s._v("lalala ${fn()} lalala")])]),s._v(" "),t("p",[s._v("3、可以嵌套")]),s._v(" "),t("h1",[t("strong",[s._v("六、函数扩展")])]),s._v(" "),t("p",[s._v("1、允许为函数的参数设置默认值，直接写在参数定义的后面即可 function log(x,y='moreng'){},默认值还可以是一个外部函数fn(),可以指定某一个参数不得省略")]),s._v(" "),t("p",[s._v("2、函数的 length属性，返回没有指定默认值的参数的个数；name属性，返回该函数的函数名")]),s._v(" "),t("p",[s._v("3、rest参数 ...变量名，利用rest参数，可以向函数传入任意数目的参数，是一个真正的数组，数组特有的方法都可以使用，作为参数时必须放在最后一位，函数的length属性不包括rest参数 ,")]),s._v(" "),t("p",[s._v("4、箭头函数定义函数")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" f = "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("v")]),s._v(" =>")]),s._v(" v;\n\n"),t("span",{staticClass:"hljs-comment"},[s._v("// 等同于")]),s._v("\n"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" f = "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" ("),t("span",{staticClass:"hljs-params"},[s._v("v")]),s._v(") ")]),s._v("{\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" v;\n};\n\n如果不需要参数或多个参数，用圆括号代表参数部分；如果代码块多于一条语句，用大括号括起来，然后用"),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v("语句返回\n\n"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" sum = "),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("num1, num2")]),s._v(") =>")]),s._v(" { "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" num1 + num2; }\n\n由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上**括号**，否则会报错。\n\n"),t("span",{staticClass:"hljs-comment"},[s._v("// 不报错")]),s._v("\n"),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" getTempItem = "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("id")]),s._v(" =>")]),s._v(" ({ "),t("span",{staticClass:"hljs-attr"},[s._v("id")]),s._v(": id, "),t("span",{staticClass:"hljs-attr"},[s._v("name")]),s._v(": "),t("span",{staticClass:"hljs-string"},[s._v('"Temp"')]),s._v(" });\n\n错。\n")])]),s._v(" "),t("h1",[t("strong",[s._v("七、数组扩展")])]),s._v(" "),t("p",[s._v("1、"),t("code",[s._v("扩展运算符 ...item 将一个数组转为用逗号分隔的参数序列，可用于函数调用")])]),s._v(" "),t("p",[s._v("2、复制数组，克隆一个全新的数组，不改变原数组，而不是仅复制指针 "),t("code",[s._v("const a2 = [...a1]")])]),s._v(" "),t("p",[s._v("3、合并数组[a1,...a2]则a1未打开，整体，合并数组[...a1,...a2,...a3]，则全平级")]),s._v(" "),t("p",[s._v("4、"),t("code",[s._v("字符串转数组 [...'hello']")])]),s._v(" "),t("p",[s._v("5、类似数组的对象（键0123）转数组 Array.from(arrayLike)，也可将字符串转数组")]),s._v(" "),t("p",[s._v("6、Array.of()返回参数值组成的数组，无参则返回空数组")]),s._v(" "),t("p",[s._v("7、数组内部复制替换（覆盖原有成员），从start开始，到end默认最后复制数组元素，从taeget位置开始替换")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-built_in"},[s._v("Array")]),s._v(".prototype.copyWithin(target, start = "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(", end = "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".length)\n\n复制"),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("到"),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v("，从"),t("span",{staticClass:"hljs-number"},[s._v("3")]),s._v("开始替换：ggg=["),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(","),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(","),t("span",{staticClass:"hljs-number"},[s._v("3")]),s._v(","),t("span",{staticClass:"hljs-number"},[s._v("4")]),s._v(","),t("span",{staticClass:"hljs-number"},[s._v("5")]),s._v("].copyWithin("),t("span",{staticClass:"hljs-number"},[s._v("3")]),s._v(","),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(","),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(")\n")])]),s._v(" "),t("p",[s._v("8、数组实例find()方法和findIndex()方法，找出第一个符合条件的数组成员、索引")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[s._v("arrayA.find("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("n")]),s._v(")=>")]),s._v(" n<"),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(")\n\narrayA.find（"),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("value,index,arr")]),s._v(")")]),s._v("{"),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" value > "),t("span",{staticClass:"hljs-number"},[s._v("9")]),s._v("}）参数依次为当前值，当前索引，原数组\n")])]),s._v(" "),t("p",[s._v('9、arrayA.fill(params),使用给定值，填充一个数组，可接受第二三个参数，表示起始位置和结束位置；填充的类型也可以为对象{aaa:"ddd"}')]),s._v(" "),t("p",[s._v("10、数组实例的 entries(),keys(),values(),分别返回一个遍历器对象，可以用for...of循环进行遍历，键值对、键名、键值")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" [index, elem] "),t("span",{staticClass:"hljs-keyword"},[s._v("of")]),s._v(" ["),t("span",{staticClass:"hljs-string"},[s._v("'a'")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'b'")]),s._v("].entries()) {\n  "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(index, elem);\n}\n"),t("span",{staticClass:"hljs-comment"},[s._v('// 0 "a"')]),s._v("\n"),t("span",{staticClass:"hljs-comment"},[s._v('// 1 "b"')]),s._v("\n")])]),s._v(" "),t("p",[s._v("11、数组实例的includes()方法，返回一个布尔值，表示某数组是否包含给定的值，第二个参数表示起始位置")]),s._v(" "),t("p",[s._v("12、.flat()将嵌套数组拉平，里面的参数表示拉平几层，Infinity则表示全部层拉平")]),s._v(" "),t("p",[s._v(".flatMap()方法对原数组每个成员执行一个函数，然后将结果拉平，仅一层，不改变原数组，")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-comment"},[s._v("// 相当于 [[2, 4], [3, 6], [4, 8]].flat()")]),s._v("\n["),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("3")]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("4")]),s._v("].flatMap("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("x")]),s._v(") =>")]),s._v(" [x, x * "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v("])\n"),t("span",{staticClass:"hljs-comment"},[s._v("// [2, 4, 3, 6, 4, 8]")]),s._v("\n")])]),s._v(" "),t("p",[s._v("13、数组空位问题，规则不统一，建议避免")]),s._v(" "),t("h1",[t("strong",[s._v("八、对象扩展")])]),s._v(" "),t("p",[s._v("1、对象属性的遍历")]),s._v(" "),t("p",[s._v("（1）for...in")]),s._v(" "),t("p",[s._v("for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。")]),s._v(" "),t("p",[s._v("（2）Object.keys(obj)")]),s._v(" "),t("p",[s._v("Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。")]),s._v(" "),t("p",[s._v("（3）Object.getOwnPropertyNames(obj)")]),s._v(" "),t("p",[s._v("Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。")]),s._v(" "),t("p",[s._v("（4）Object.getOwnPropertySymbols(obj)")]),s._v(" "),t("p",[s._v("Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。")]),s._v(" "),t("p",[s._v("（5）Reflect.ownKeys(obj)")]),s._v(" "),t("p",[s._v("Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。")]),s._v(" "),t("p",[s._v("以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。")]),s._v(" "),t("p",[s._v("首先遍历所有数值键，按照数值升序排列。")]),s._v(" "),t("p",[s._v("其次遍历所有字符串键，按照加入时间升序排列。")]),s._v(" "),t("p",[s._v("最后遍历所有 Symbol 键，按照加入时间升序排列。")]),s._v(" "),t("p",[s._v("2、对象的解构赋值可用于从一个对象取值")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" { x, y, ...z } = { "),t("span",{staticClass:"hljs-attr"},[s._v("x")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-attr"},[s._v("y")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", "),t("span",{staticClass:"hljs-attr"},[s._v("a")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("3")]),s._v(", "),t("span",{staticClass:"hljs-attr"},[s._v("b")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("4")]),s._v(" };\nx "),t("span",{staticClass:"hljs-comment"},[s._v("// 1")]),s._v("\ny "),t("span",{staticClass:"hljs-comment"},[s._v("// 2")]),s._v("\nz "),t("span",{staticClass:"hljs-comment"},[s._v("// { a: 3, b: 4 }")]),s._v("\n")])]),s._v(" "),t("p",[s._v("3、扩展运算符 ...objecctA 用于取出参数对象的所有可遍历属性，拷贝到当前对象中")]),s._v(" "),t("p",[s._v("...后可以为表达式 （x>1?{a:1}:{}）")]),s._v(" "),t("p",[s._v("可用于数组，转为对象")]),s._v(" "),t("p",[s._v("其他值 如 true,1,undefined,null会转为空对象{}")]),s._v(" "),t("p",[s._v('字符串会转为一个类似数组的对象{0："h",1:"e"......}')]),s._v(" "),t("p",[s._v("等同于使用Object.assign({},objectA)方法")]),s._v(" "),t("h1",[t("strong",[s._v("九、对象的新增方法")])]),s._v(" "),t("p",[s._v("1、"),t("strong",[s._v("Object.is(a,b)比较两个只是否严格相等")]),s._v("，同===，除了+0-0false，NaN与NaNtrue")]),s._v(" "),t("p",[s._v("2、**Object.assign(a,b,c)对象合并,将bc合并到a,同名属性会覆盖;**只有一个参数，不是对象的转成对象，是对象的返回该参数，undefined和null无法转对象，在首位会报错其他位置会跳过。")]),s._v(" "),t("p",[s._v("3、"),t("strong",[s._v("Object.assign()方法是浅拷贝")]),s._v("，源对象如果改变，会随之改变；同名会替换；数组会当成对象处理，造成对应位置替换；如果复制的是一个取值函数，仅会复制求值后的值")]),s._v(" "),t("p",[s._v("常用于为对象添加属性、方法、合并、克隆、为属性指定默认值")]),s._v(" "),t("p",[s._v("4、"),t("strong",[s._v("Object.keys()")]),s._v(",Object.values(),Object.entries()同数组用法基本一致，供for ...of x循环使用")]),s._v(" "),t("p",[s._v("5、Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象")]),s._v(" "),t("p",[t("strong",[s._v("十、Symbol")])]),s._v(" "),t("p",[s._v("1、一种新的原始数据类型，用Symbol函数生成，不是对象，是一种类似于字符串的数据类型。")]),s._v(" "),t("p",[s._v("let s = Symbol();可以接受一个字符串作为参数，表示描述，主要是为了在控制台显示或转为字符串时便于区分 let s1 = Symbol('foo')")]),s._v(" "),t("p",[s._v("2、不能与其他类型的值进行运算、可以显式转为字符串、String() .toString、也可以转为布尔值，但不能转为数值")]),s._v(" "),t("p",[s._v("3、用于属性名时，let mySymbol = Symbol();可以a[mySymbol] = '....'，或者[mySymbol]:'....',或者")]),s._v(" "),t("p",[s._v("let a = {};\nObject.defineProperty(a, mySymbol, { value: 'Hello!' });")]),s._v(" "),t("p",[s._v("不能用点运算符，因为点运算符后面总是字符串")]),s._v(" "),t("p",[s._v("4、Symbol作为属性名，不会出现在for..in for...of 循环中，也不会被object.keys()返回，但是也不是私有属性，用Object.getOwnPropertySymbols()方法，可以获取指定对象的所有symbol属性名")]),s._v(" "),t("p",[s._v("5、Reflect.ownKeys(obj)可以返回所有类型的键名，包括常规名和Symbol键名")]),s._v(" "),t("p",[s._v("6、Symbol.for('')生成新的Symbol,登记在全局环境供搜索，不会每次调用就返回一个新的值，可以创建同一个Symbol值；Symbol.keyfor()返回一个已登记的Symbol类型值的key")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" s1 = "),t("span",{staticClass:"hljs-built_in"},[s._v("Symbol")]),s._v(".for("),t("span",{staticClass:"hljs-string"},[s._v('"foo"')]),s._v(");\n"),t("span",{staticClass:"hljs-built_in"},[s._v("Symbol")]),s._v(".keyFor(s1) "),t("span",{staticClass:"hljs-comment"},[s._v('// "foo"')]),s._v("\n\n"),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" s2 = "),t("span",{staticClass:"hljs-built_in"},[s._v("Symbol")]),s._v("("),t("span",{staticClass:"hljs-string"},[s._v('"foo"')]),s._v(");\n"),t("span",{staticClass:"hljs-built_in"},[s._v("Symbol")]),s._v(".keyFor(s2) "),t("span",{staticClass:"hljs-comment"},[s._v("// undefined")]),s._v("\n")])]),s._v(" "),t("h1",[t("strong",[s._v("十一、Set数据结构")])]),s._v(" "),t("p",[s._v("1、let set = new Set()。es6提供的新的数据结构，类似于数组，但是成员的值都是"),t("strong",[s._v("唯一")]),s._v("的，set本身"),t("strong",[s._v("是一个构造函数，用来生成Set数据结构")]),s._v("。"),t("strong",[s._v("s.add(x)向s添加成员，发现不会添加重复的值")])]),s._v(" "),t("p",[s._v("2、去除数组重复成员[...new Set(array)]；去除字符串重复字符[...new Set('ababbc')].join('')；不会发生类型转换，5和‘5’是不同的值")]),s._v(" "),t("p",[s._v("3、在 Set 内部，两个NaN是相等。"),t("strong",[s._v("两个对象总是不相等的")])]),s._v(" "),t("p",[s._v("4、Set 结构的实例有以下属性。")]),s._v(" "),t("ul",[t("li",[s._v("Set.prototype.constructor：构造函数，默认就是Set函数。")]),s._v(" "),t("li",[s._v("Set.prototype.size：返回Set实例的成员总数。")])]),s._v(" "),t("p",[s._v("四个操作方法：")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[s._v("- add(value)：添加某个值，返回 "),t("span",{staticClass:"hljs-built_in"},[s._v("Set")]),s._v(" 结构本身。\n- "),t("span",{staticClass:"hljs-keyword"},[s._v("delete")]),s._v("(value)：删除某个值，返回一个布尔值，表示删除是否成功。\n- has(value)：返回一个布尔值，表示该值是否为"),t("span",{staticClass:"hljs-built_in"},[s._v("Set")]),s._v("的成员。\n- clear()：清除所有成员，没有返回值。\n")])]),s._v(" "),t("p",[s._v("四个遍历方法：")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("keys()：返回键名的遍历器")])]),s._v(" "),t("li",[t("strong",[s._v("values()：返回键值的遍历器")])]),s._v(" "),t("li",[t("strong",[s._v("entries()：返回键值对的遍历器")])]),s._v(" "),t("li",[t("strong",[s._v("forEach()：使用回调函数遍历每个成员")])])]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("set")]),s._v(" = new Set(['red', 'green', 'blue']);\nfor (let item of "),t("span",{staticClass:"hljs-keyword"},[s._v("set")]),s._v(".keys()) {\n  "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(item);\n}\n")])]),s._v(" "),t("p",[s._v("5、WeakSet是一个构造函数，可以使用new命令，创建 WeakSet 数据结构")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" ws = "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("WeakSet")]),s._v("();"),t("span",{staticClass:"hljs-built_in"},[s._v("WeakSet")]),s._v(" 的成员只能是对象，而不能是其他类型的值\n")])]),s._v(" "),t("p",[s._v("三个方法:")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-built_in"},[s._v("WeakSet")]),s._v(".prototype.add(value)：向 "),t("span",{staticClass:"hljs-built_in"},[s._v("WeakSet")]),s._v(" 实例添加一个新成员。\n\n"),t("span",{staticClass:"hljs-built_in"},[s._v("WeakSet")]),s._v(".prototype.delete(value)：清除 "),t("span",{staticClass:"hljs-built_in"},[s._v("WeakSet")]),s._v(" 实例的指定成员。\n\n"),t("span",{staticClass:"hljs-built_in"},[s._v("WeakSet")]),s._v(".prototype.has(value)：返回一个布尔值，表示某个值是否在\n")])]),s._v(" "),t("h1",[t("strong",[s._v("十二、Map")])]),s._v(" "),t("p",[s._v("1、const m = new Map();类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，"),t("strong",[s._v("Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。")])]),s._v(" "),t("p",[s._v("2、map中键是一个简单类型的值（数字、字符串、布尔值），"),t("strong",[s._v("则只要两个值严格相等，Map 将其视为一个键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。")])]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[s._v("map.set("),t("span",{staticClass:"hljs-number"},[s._v("-0")]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("123")]),s._v(");\nmap.get(+"),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(") "),t("span",{staticClass:"hljs-comment"},[s._v("// 123")]),s._v("\n")])]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[s._v("map.set("),t("span",{staticClass:"hljs-literal"},[s._v("NaN")]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("123")]),s._v(");\nmap.get("),t("span",{staticClass:"hljs-literal"},[s._v("NaN")]),s._v(") "),t("span",{staticClass:"hljs-comment"},[s._v("// 123")]),s._v("\n")])]),s._v(" "),t("p",[s._v("3、属性和操作方法")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[s._v(".size属性返回 "),t("span",{staticClass:"hljs-built_in"},[s._v("Map")]),s._v(" 结构的成员总数\n\n.set(key, value)方法设置键名key对应的键值为value\n\n.get(key)方法读取key对应的键值\n\n.has(key)方法返回一个布尔值，表示某个键是否在当前 "),t("span",{staticClass:"hljs-built_in"},[s._v("Map")]),s._v(" 对象之中\n\n.delete(key)方法删除某个键\n\n.clear()方法清除所有成员，没有返回值\n\n遍历方法：\n\n.keys()：返回键名的遍历器。\n\n.values()：返回键值的遍历器。\n\n.entries()：返回所有成员的遍历器。\n\n.forEach()：遍历 "),t("span",{staticClass:"hljs-built_in"},[s._v("Map")]),s._v(" 的所有成员。\n")])]),s._v(" "),t("p",[s._v("4、Map 结构转为数组结构，比较快速的方法是使用扩展运算符（...）。结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法）。")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" map = "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Map")]),s._v("([\n  ["),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'one'")]),s._v("],\n  ["),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'two'")]),s._v("],\n  ["),t("span",{staticClass:"hljs-number"},[s._v("3")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'three'")]),s._v("],\n]);\n\n[...map.keys()]\n"),t("span",{staticClass:"hljs-comment"},[s._v("// [1, 2, 3]")]),s._v("\n")])]),s._v(" "),t("p",[s._v("5、与其他数据结构的互相转换")]),s._v(" "),t("p",[s._v("Map 转为数组 [...map1]")]),s._v(" "),t("p",[s._v("数组 转为 Map,将数组传入Map构造函数即可  new Map([    [trew,7] ,  [ {foo:3},['abc'] ]    ])")]),s._v(" "),t("p",[s._v("map转对象 ，如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名")]),s._v(" "),t("p",[s._v("对象转为 Map，Map 转为 JSON，JSON 转为 Map （案例略，见官网）")]),s._v(" "),t("p",[s._v("6、WeakMap：只接受对象作为键名（null除外），不接受其他类型的值作为键名；WeakMap的键名所指向的对象，不计入垃圾回收机制。没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性。WeakMap 应用的典型场合就是 DOM 节点作为键名。")]),s._v(" "),t("h1",[t("strong",[s._v("十三、Proxy")])]),s._v(" "),t("p",[s._v("用于修改某些操作的默认行为，等同于在语言层面做出修改，可以理解成，在目标对象之前架设一层“拦截”。ES6 原生提供 "),t("strong",[s._v("Proxy 构造函数")]),s._v("，用来生成 Proxy 实例。")]),s._v(" "),t("p",[s._v("var proxy = new Proxy(target, handler);")]),s._v(" "),t("p",[s._v("下面是 Proxy 支持的拦截操作一览，一共 13 种。（具体见官网）")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[s._v("- "),t("span",{staticClass:"hljs-keyword"},[s._v("get")]),s._v("(target, propKey, receiver)：\n拦截对象属性的读取，比如proxy.foo和proxy['foo']。\n- "),t("span",{staticClass:"hljs-keyword"},[s._v("set")]),s._v("(target, propKey, value, receiver)：\n拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。\n- has(target, propKey)：\n拦截propKey in proxy的操作，返回一个布尔值。\n- deleteProperty(target, propKey)：\n拦截delete proxy[propKey]的操作，返回一个布尔值。\n- ownKeys(target)：\n拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。\n- getOwnPropertyDescriptor(target, propKey)：\n拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。\n- defineProperty(target, propKey, propDesc)：\n拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。\n- preventExtensions(target)：\n拦截Object.preventExtensions(proxy)，返回一个布尔值。\n- getPrototypeOf(target)：\n拦截Object.getPrototypeOf(proxy)，返回一个对象。\n- isExtensible(target)：\n拦截Object.isExtensible(proxy)，返回一个布尔值。\n- setPrototypeOf(target, proto)：\n拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。\n- apply(target, object, args)：\n拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。\n- construct(target, args)：\n拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。\n")])]),s._v(" "),t("h1",[t("strong",[s._v("十四、Reflect")])]),s._v(" "),t("p",[s._v("Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的方法与Proxy对象的方法一一对应，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。（具体方法见官网）")]),s._v(" "),t("h1",[t("strong",[s._v("十五、Promise对象")])]),s._v(" "),t("p",[s._v("1、Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。")]),s._v(" "),t("p",[s._v("2、ES6 规定，Promise对象是一个构造函数，用来生成Promise实例")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" promise = "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v("("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("resolve, reject")]),s._v(") ")]),s._v("{\n  "),t("span",{staticClass:"hljs-comment"},[s._v("// ... some code")]),s._v("\n\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" ("),t("span",{staticClass:"hljs-comment"},[s._v("/* 异步操作成功 */")]),s._v("){\n    resolve(value);\n  } "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" {\n    reject(error);\n  }\n});\n")])]),s._v(" "),t("p",[s._v("Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject")]),s._v(" "),t("p",[s._v("resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。")]),s._v(" "),t("p",[s._v("Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[s._v("promise.then("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("value")]),s._v(") ")]),s._v("{\n  "),t("span",{staticClass:"hljs-comment"},[s._v("// success")]),s._v("\n}, "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("error")]),s._v(") ")]),s._v("{\n  "),t("span",{staticClass:"hljs-comment"},[s._v("// failure")]),s._v("\n});\n")])]),s._v(" "),t("p",[s._v("then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。")]),s._v(" "),t("p",[s._v("3、举例")]),s._v(" "),t("p",[s._v("下面是一个Promise对象的简单例子。")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("timeout")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("ms")]),s._v(") ")]),s._v("{\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v("("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("resolve, reject")]),s._v(") =>")]),s._v(" {\n    setTimeout(resolve, ms, "),t("span",{staticClass:"hljs-string"},[s._v("'done'")]),s._v(");\n  });\n}\n\ntimeout("),t("span",{staticClass:"hljs-number"},[s._v("100")]),s._v(").then("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("value")]),s._v(") =>")]),s._v(" {\n  "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(value);\n});\n")])]),s._v(" "),t("p",[s._v("上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。")]),s._v(" "),t("p",[t("strong",[s._v("4、Promise.prototype.then()")])]),s._v(" "),t("p",[s._v("Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。")]),s._v(" "),t("p",[s._v("then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[s._v("getJSON("),t("span",{staticClass:"hljs-string"},[s._v('"/posts.json"')]),s._v(").then("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("json")]),s._v(") ")]),s._v("{\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" json.post;\n}).then("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("post")]),s._v(") ")]),s._v("{\n  "),t("span",{staticClass:"hljs-comment"},[s._v("// ...")]),s._v("\n});\n")])]),s._v(" "),t("p",[t("strong",[s._v("5、Promise.prototype.catch()")])]),s._v(" "),t("p",[s._v("Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。")]),s._v(" "),t("p",[s._v("上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。")]),s._v(" "),t("p",[s._v("6、一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-comment"},[s._v("// bad")]),s._v("\npromise\n  .then("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("data")]),s._v(") ")]),s._v("{\n    "),t("span",{staticClass:"hljs-comment"},[s._v("// success")]),s._v("\n  }, "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("err")]),s._v(") ")]),s._v("{\n    "),t("span",{staticClass:"hljs-comment"},[s._v("// error")]),s._v("\n  });\n\n"),t("span",{staticClass:"hljs-comment"},[s._v("// good")]),s._v("\npromise\n  .then("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("data")]),s._v(") ")]),s._v("{ "),t("span",{staticClass:"hljs-comment"},[s._v("//cb")]),s._v("\n    "),t("span",{staticClass:"hljs-comment"},[s._v("// success")]),s._v("\n  })\n  .catch("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("err")]),s._v(") ")]),s._v("{\n    "),t("span",{staticClass:"hljs-comment"},[s._v("// error")]),s._v("\n  });\n")])]),s._v(" "),t("p",[s._v("上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。")]),s._v(" "),t("p",[s._v("7、一般总是建议，Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误。catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。")]),s._v(" "),t("p",[t("strong",[s._v("8、Promise.prototype.finally()")])]),s._v(" "),t("p",[s._v("finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。")]),s._v(" "),t("p",[s._v("上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。")]),s._v(" "),t("p",[t("strong",[s._v("9、Promise.all()")])]),s._v(" "),t("p",[s._v("Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理")]),s._v(" "),t("p",[s._v("const p = Promise.all([p1, p2, p3]);")]),s._v(" "),t("p",[s._v("p的状态由p1、p2、p3决定，&&&。实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数")]),s._v(" "),t("p",[t("strong",[s._v("10、Promise.race")])]),s._v(" "),t("p",[s._v("同样是将多个 Promise 实例，包装成一个新的 Promise 实例。")]),s._v(" "),t("p",[s._v("const p = Promise.race([p1, p2, p3]);")]),s._v(" "),t("p",[s._v("上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数")]),s._v(" "),t("p",[s._v("举例应用，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" p = "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v(".race([\n  fetch("),t("span",{staticClass:"hljs-string"},[s._v("'/resource-that-may-take-a-while'")]),s._v("),\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v("("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" ("),t("span",{staticClass:"hljs-params"},[s._v("resolve, reject")]),s._v(") ")]),s._v("{\n    setTimeout("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" =>")]),s._v(" reject("),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Error")]),s._v("("),t("span",{staticClass:"hljs-string"},[s._v("'request timeout'")]),s._v(")), "),t("span",{staticClass:"hljs-number"},[s._v("5000")]),s._v(")\n  })\n]);\n\np\n.then("),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log)\n.catch("),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".error);\n")])]),s._v(" "),t("p",[s._v("上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。")]),s._v(" "),t("p",[t("strong",[s._v("11、Promise.resolve()")])]),s._v(" "),t("p",[s._v("将现有对象转为 Promise 对象。Promise.resolve等价于下面的写法。")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v(".resolve("),t("span",{staticClass:"hljs-string"},[s._v("'foo'")]),s._v(")\n"),t("span",{staticClass:"hljs-comment"},[s._v("// 等价于")]),s._v("\n"),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v("("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("resolve")]),s._v(" =>")]),s._v(" resolve("),t("span",{staticClass:"hljs-string"},[s._v("'foo'")]),s._v("))\n")])]),s._v(" "),t("p",[s._v("Promise.resolve方法的参数分成四种情况：")]),s._v(" "),t("p",[s._v("①如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例")]),s._v(" "),t("p",[s._v("②thenable对象即具有then方法的对象，会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。")]),s._v(" "),t("p",[s._v("③是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved")]),s._v(" "),t("p",[s._v("④Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。")]),s._v(" "),t("p",[t("strong",[s._v("12、Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。")])]),s._v(" "),t("p",[s._v("Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。")]),s._v(" "),t("p",[t("strong",[s._v("13、Promise.try()")])]),s._v(" "),t("p",[s._v("可以统一用promise.catch()捕获所有同步和异步的错误。")]),s._v(" "),t("p",[s._v("Promise.try(() => database.users.get({id: userId}))\n.then(...)\n.catch(...)")]),s._v(" "),t("p",[s._v("事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。")]),s._v(" "),t("h1",[t("strong",[s._v("十六、遍历器 Iterator")])]),s._v(" "),t("p",[s._v("1、遍历器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。作用：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。")]),s._v(" "),t("p",[s._v("2、默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被for...of循环遍历。原因在于，这些数据结构原生部署了Symbol.iterator属性。一个对象如果要具备可被for...of循环调用的 Iterator 接口，就必须在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。")]),s._v(" "),t("p",[s._v("3、对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定（具体见官网）")]),s._v(" "),t("p",[s._v("4、原生具备 Iterator 接口的数据结构如下。")]),s._v(" "),t("p",[s._v("Array、Map、Set、String、TypedArray、函数的 arguments 对象、NodeList 对象")]),s._v(" "),t("p",[s._v("5、字符串的 Iterator 接口")]),s._v(" "),t("p",[s._v("字符串是一个类似数组的对象，也原生具有 Iterator 接口。")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" someString = "),t("span",{staticClass:"hljs-string"},[s._v('"hi"')]),s._v(";\n"),t("span",{staticClass:"hljs-keyword"},[s._v("typeof")]),s._v(" someString["),t("span",{staticClass:"hljs-built_in"},[s._v("Symbol")]),s._v(".iterator]\n"),t("span",{staticClass:"hljs-comment"},[s._v('// "function"')]),s._v("\n\n"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" iterator = someString["),t("span",{staticClass:"hljs-built_in"},[s._v("Symbol")]),s._v(".iterator]();\n\niterator.next()  "),t("span",{staticClass:"hljs-comment"},[s._v('// { value: "h", done: false }')]),s._v("\niterator.next()  "),t("span",{staticClass:"hljs-comment"},[s._v('// { value: "i", done: false }')]),s._v("\niterator.next()  "),t("span",{staticClass:"hljs-comment"},[s._v("// { value: undefined, done: true }")]),s._v("\n")])]),s._v(" "),t("p",[s._v("上面代码中，调用Symbol.iterator方法返回一个遍历器对象，在这个遍历器上可以调用 next 方法，实现对于字符串的遍历。")]),s._v(" "),t("p",[s._v("6、遍历器对象的方法 next(),return(),throw()")]),s._v(" "),t("p",[s._v("如果你自己写遍历器对象生成函数，那么next方法是必须部署的")]),s._v(" "),t("p",[s._v("return方法的使用场合是，如果for...of循环提前退出（通常是因为出错，或者有break语句），就会调用return方法")]),s._v(" "),t("p",[s._v("throw方法主要是配合 Generator 函数使用")]),s._v(" "),t("p",[s._v("7、for...of 循环")]),s._v(" "),t("p",[t("strong",[s._v("数组")])]),s._v(" "),t("p",[s._v("数组原生具备iterator接口（即默认部署了Symbol.iterator属性），for...of循环本质上就是调用这个接口产生的遍历器。for...in循环读取键名，for...of循环读取键值。如果要通过for...of循环，获取数组的索引，可以借助数组实例的entries方法和keys方法")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" arr = ["),t("span",{staticClass:"hljs-string"},[s._v("'red'")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'green'")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'blue'")]),s._v("];\n"),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v("("),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" v "),t("span",{staticClass:"hljs-keyword"},[s._v("of")]),s._v(" arr) {\n  "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(v); "),t("span",{staticClass:"hljs-comment"},[s._v("// red green blue")]),s._v("\n}\n\n"),t("span",{staticClass:"hljs-comment"},[s._v("// 如下，本质上是调用这个接口产生的遍历器，结果一致")]),s._v("\n\n"),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" obj = {};\nobj["),t("span",{staticClass:"hljs-built_in"},[s._v("Symbol")]),s._v(".iterator] = arr["),t("span",{staticClass:"hljs-built_in"},[s._v("Symbol")]),s._v(".iterator].bind(arr);\n\n"),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v("("),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" v "),t("span",{staticClass:"hljs-keyword"},[s._v("of")]),s._v(" obj) {\n  "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(v); "),t("span",{staticClass:"hljs-comment"},[s._v("// red green blue")]),s._v("\n}\n")])]),s._v(" "),t("p",[t("strong",[s._v("Set 和 Map 结构")])]),s._v(" "),t("p",[s._v("Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用for...of循环；遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值")]),s._v(" "),t("p",[t("strong",[s._v("计算生成的数据结构")])]),s._v(" "),t("p",[s._v("有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。")]),s._v(" "),t("ul",[t("li",[s._v("entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用entries方法。")]),s._v(" "),t("li",[s._v("keys() 返回一个遍历器对象，用来遍历所有的键名。")]),s._v(" "),t("li",[s._v("values() 返回一个遍历器对象，用来遍历所有的键值。")])]),s._v(" "),t("p",[s._v("一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" key "),t("span",{staticClass:"hljs-keyword"},[s._v("of")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Object")]),s._v(".keys(someObject)) {\n  "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(key + "),t("span",{staticClass:"hljs-string"},[s._v("': '")]),s._v(" + someObject[key]);\n}\n")])]),s._v(" "),t("h1",[t("strong",[s._v("十七、Generator函数")])]),s._v(" "),t("p",[s._v("1、Generator 函数是 ES6 提供的一种异步编程解决方案，function关键字与函数名之间有一个星号；函数体内部使用yield表达式，定义不同的内部状态")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("* "),t("span",{staticClass:"hljs-title"},[s._v("helloWorldGenerator")]),s._v("("),t("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("yield")]),s._v(" "),t("span",{staticClass:"hljs-string"},[s._v("'hello'")]),s._v(";\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("yield")]),s._v(" "),t("span",{staticClass:"hljs-string"},[s._v("'world'")]),s._v(";\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-string"},[s._v("'ending'")]),s._v(";\n}\n\n"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" hw = helloWorldGenerator();\n\n逐步调用next方法，会一步步执行函数内的"),t("span",{staticClass:"hljs-keyword"},[s._v("yield")]),s._v("状态,否则不会执行；"),t("span",{staticClass:"hljs-keyword"},[s._v("yield")]),s._v("表达式就是暂停标志\n\nhw.next()\n"),t("span",{staticClass:"hljs-comment"},[s._v("// { value: 'hello', done: false }")]),s._v("\nhw.next()\n"),t("span",{staticClass:"hljs-comment"},[s._v("// { value: 'world', done: false }")]),s._v("\nhw.next()\n"),t("span",{staticClass:"hljs-comment"},[s._v("// { value: 'ending', done: true }")]),s._v("\nhw.next()\n"),t("span",{staticClass:"hljs-comment"},[s._v("// { value: undefined, done: true }")]),s._v("\n")])]),s._v(" "),t("p",[s._v("其他（见官网）")]),s._v(" "),t("h1",[t("strong",[s._v("十八、async函数")])]),s._v(" "),t("p",[s._v("1、async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。")]),s._v(" "),t("p",[s._v("2、对对 Generator 函数的改进，体现：")]),s._v(" "),t("p",[s._v("①async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行")]),s._v(" "),t("p",[s._v("asyncReadFile();")]),s._v(" "),t("p",[s._v("②async和await，比起星号和yield，语义更清楚了。")]),s._v(" "),t("p",[s._v("③更广的适用性。")]),s._v(" "),t("p",[s._v("co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）")]),s._v(" "),t("p",[s._v("④"),t("strong",[s._v("async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作")])]),s._v(" "),t("p",[s._v("3、"),t("strong",[s._v("async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。")])]),s._v(" "),t("p",[s._v("下面是另一个例子，指定多少毫秒后输出一个值。")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("timeout")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("ms")]),s._v(") ")]),s._v("{\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v("("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("resolve")]),s._v(") =>")]),s._v(" {\n    setTimeout(resolve, ms);\n  });\n}\n\n"),t("span",{staticClass:"hljs-keyword"},[s._v("async")]),s._v(" "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("asyncPrint")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("value, ms")]),s._v(") ")]),s._v("{\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("await")]),s._v(" timeout(ms);\n  "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(value);\n}\n\nasyncPrint("),t("span",{staticClass:"hljs-string"},[s._v("'hello world'")]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("50")]),s._v(");\n")])]),s._v(" "),t("p",[t("strong",[s._v("4、async函数返回一个 Promise 对象。")])]),s._v(" "),t("p",[t("strong",[s._v("async函数内部return语句返回的值，会成为then方法回调函数的参数。")])]),s._v(" "),t("p",[t("strong",[s._v("async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。")])]),s._v(" "),t("p",[s._v("5、有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在"),t("code",[s._v("try...catch")]),s._v("结构里面，这样不管这个异步操作是否成功，第二个await都会执行。")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-keyword"},[s._v("async")]),s._v(" "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("f")]),s._v("("),t("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("try")]),s._v(" {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("await")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v(".reject("),t("span",{staticClass:"hljs-string"},[s._v("'出错了'")]),s._v(");\n  } "),t("span",{staticClass:"hljs-keyword"},[s._v("catch")]),s._v("(e) {\n  }\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("await")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v(".resolve("),t("span",{staticClass:"hljs-string"},[s._v("'hello world'")]),s._v(");\n}\n\nf()\n.then("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("v")]),s._v(" =>")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(v))\n"),t("span",{staticClass:"hljs-comment"},[s._v("// hello world")]),s._v("\n")])]),s._v(" "),t("p",[s._v("另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-keyword"},[s._v("async")]),s._v(" "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("f")]),s._v("("),t("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("await")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v(".reject("),t("span",{staticClass:"hljs-string"},[s._v("'出错了'")]),s._v(")\n    .catch("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("e")]),s._v(" =>")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(e));\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("await")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v(".resolve("),t("span",{staticClass:"hljs-string"},[s._v("'hello world'")]),s._v(");\n}\n\nf()\n.then("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("v")]),s._v(" =>")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(v))\n"),t("span",{staticClass:"hljs-comment"},[s._v("// 出错了")]),s._v("\n"),t("span",{staticClass:"hljs-comment"},[s._v("// hello world")]),s._v("\n")])]),s._v(" "),t("p",[s._v("6、await命令只能用在async函数之中，如果用在普通函数，就会报错")]),s._v(" "),t("p",[s._v("如果确实希望多个请求并发执行，可以使用Promise.all方法")]),s._v(" "),t("p",[s._v("7、与其他异步处理方法Promise、Generator 函数比较， Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。")]),s._v(" "),t("p",[s._v("对象的方")]),s._v(" "),t("h1",[t("strong",[s._v("十九、类Class")])]),s._v(" "),t("p",[t("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/class"}},[s._v("ES6 入门教程")])]),s._v(" "),t("h2",[s._v("class的定义")]),s._v(" "),t("p",[s._v("class是es6的一个新的定义，它的内部原理其实就是es5的构造函数和原型，它的本质是一个构造函数。")]),s._v(" "),t("p",[s._v("在es5当中，我们通过function A{}的方式来编写一个构造函数，然后通过A.prototype.methods1的方式给构造函数的原型绑定一些方法，用new A 的方式从构造函数生成实例对象，从而这个实例对象可拥有这些方法和构造函数中的参数。如下：")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("Point")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("x, y")]),s._v(") ")]),s._v("{\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".x = x;\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".y = y;\n}\n\nPoint.prototype.toString = "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" ("),t("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-string"},[s._v("'('")]),s._v(" + "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".x + "),t("span",{staticClass:"hljs-string"},[s._v("', '")]),s._v(" + "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".y + "),t("span",{staticClass:"hljs-string"},[s._v("')'")]),s._v(";\n};\n\n"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" p = "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" Point("),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(");\n")])]),s._v(" "),t("p",[s._v("但这种编写方式不是很一体，因此es6通过class，将构造函数和原型方法整合到了一起，如下：")]),s._v(" "),t("p",[s._v("ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让"),t("strong",[s._v("对象原型的写法更加清晰、更像面向对象编程的语法")]),s._v("而已")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-class"},[t("span",{staticClass:"hljs-keyword"},[s._v("class")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("Point")]),s._v(" ")]),s._v("{\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("constructor")]),s._v("(x, y) {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".x = x;"),t("span",{staticClass:"hljs-comment"},[s._v("// 这是构造函数中的内容")]),s._v("\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".y = y;\n  }\n\n  toString() {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-string"},[s._v("'这其实是绑在原型上的方法('")]),s._v(" + "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".x + "),t("span",{staticClass:"hljs-string"},[s._v("', '")]),s._v(" + "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".y + "),t("span",{staticClass:"hljs-string"},[s._v("')'")]),s._v(";\n  }\n}\n")])]),s._v(" "),t("h2",[s._v("class继承")]),s._v(" "),t("p",[s._v("class类可以通过 extends关键词继承，如："),t("code",[s._v("classA extends classB")]),s._v("，，注意继承中，一定要用到super()方法，表示A继承了B的构造函数和原型上的方法")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-class"},[t("span",{staticClass:"hljs-keyword"},[s._v("class")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("A")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("extends")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("B")]),s._v(" ")]),s._v("{\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("constructor")]),s._v("(x, y, color) {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("super")]),s._v("(x, y); "),t("span",{staticClass:"hljs-comment"},[s._v("// 调用父类的constructor(x, y)")]),s._v("\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".color = color;\n  }\n\n  toString() {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".color + "),t("span",{staticClass:"hljs-string"},[s._v("' '")]),s._v(" + "),t("span",{staticClass:"hljs-keyword"},[s._v("super")]),s._v(".toString(); "),t("span",{staticClass:"hljs-comment"},[s._v("// 调用父类的toString()")]),s._v("\n  }\n}\n")])]),s._v(" "),t("h1",[t("strong",[s._v("二十、Module模块")])]),s._v(" "),t("p",[s._v("1、JS的模块体系，"),t("strong",[s._v("静态加载")]),s._v("。"),t("strong",[s._v("export命令可以出现在模块的任何位置，只要处于模块顶层就可以")]),s._v("。如果处于块级作用域内，就会报错，import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。")]),s._v(" "),t("p",[s._v("2、ES6的模块自动采用严格模式，主要有以下限制")]),s._v(" "),t("ul",[t("li",[s._v("变量必须声明后再使用")]),s._v(" "),t("li",[s._v("函数的参数不能有同名属性，否则报错")]),s._v(" "),t("li",[s._v("不能使用with语句")]),s._v(" "),t("li",[s._v("不能对只读属性赋值，否则报错")]),s._v(" "),t("li",[s._v("不能使用前缀 0 表示八进制数，否则报错")]),s._v(" "),t("li",[s._v("不能删除不可删除的属性，否则报错")]),s._v(" "),t("li",[s._v("不能删除变量delete prop，会报错，只能删除属性delete global[prop]")]),s._v(" "),t("li",[s._v("eval不会在它的外层作用域引入变量")]),s._v(" "),t("li",[s._v("eval和arguments不能被重新赋值")]),s._v(" "),t("li",[s._v("arguments不会自动反映函数参数的变化")]),s._v(" "),t("li",[s._v("不能使用arguments.callee")]),s._v(" "),t("li",[s._v("不能使用arguments.caller")]),s._v(" "),t("li",[s._v("禁止this指向全局对象")]),s._v(" "),t("li",[s._v("不能使用fn.caller和fn.arguments获取函数调用的堆栈")]),s._v(" "),t("li",[s._v("增加了保留字（比如protected、static和interface）")])]),s._v(" "),t("p",[s._v("3、模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能")]),s._v(" "),t("p",[s._v("4、export命令：一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。")]),s._v(" "),t("p",[s._v("5、export命令除了输出变量，还可以输出函数或类（class）。")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-keyword"},[s._v("export")]),s._v(" {firstName, lastName, year};\n\n"),t("span",{staticClass:"hljs-keyword"},[s._v("export")]),s._v(" "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("multiply")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("x, y")]),s._v(") ")]),s._v("{\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" x * y;\n};\n\n"),t("span",{staticClass:"hljs-keyword"},[s._v("export")]),s._v("输出的变量就是本来的名字，但是可以使用"),t("span",{staticClass:"hljs-keyword"},[s._v("as")]),s._v("关键字重命名\n\n"),t("span",{staticClass:"hljs-keyword"},[s._v("export")]),s._v(" {\n  v1 "),t("span",{staticClass:"hljs-keyword"},[s._v("as")]),s._v(" streamV1,\n  v2 "),t("span",{staticClass:"hljs-keyword"},[s._v("as")]),s._v(" streamV2,\n  v2 "),t("span",{staticClass:"hljs-keyword"},[s._v("as")]),s._v(" streamLatestVersion\n};\n")])]),s._v(" "),t("p",[s._v("6、使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。import命令，用于加载profile.js文件，并从中输入变量。import命令接受一对大括号，里面指定要从其他模块导入的变量名。")]),s._v(" "),t("p",[s._v("如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。")]),s._v(" "),t("p",[t("code",[s._v("import { lastName as surname } from './profile.js';")])]),s._v(" "),t("p",[s._v("from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js后缀可以省略")]),s._v(" "),t("p",[s._v("7、模块的整体加载")]),s._v(" "),t("p",[s._v("除了加载某个输出值，也可以整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。假设一个circle.js文件，它输出两个方法area和circumference。加载这个模块可以：")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-keyword"},[s._v("import")]),s._v(" * "),t("span",{staticClass:"hljs-keyword"},[s._v("as")]),s._v(" circle "),t("span",{staticClass:"hljs-keyword"},[s._v("from")]),s._v(" "),t("span",{staticClass:"hljs-string"},[s._v("'./circle'")]),s._v(";\n"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),t("span",{staticClass:"hljs-string"},[s._v("'圆面积：'")]),s._v(" + circle.area("),t("span",{staticClass:"hljs-number"},[s._v("4")]),s._v("));\n"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),t("span",{staticClass:"hljs-string"},[s._v("'圆周长：'")]),s._v(" + circle.circumference("),t("span",{staticClass:"hljs-number"},[s._v("14")]),s._v("));\n")])]),s._v(" "),t("p",[s._v("8、export default 命令")]),s._v(" "),t("p",[s._v("export default命令，为模块指定默认输出。")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-comment"},[s._v("// export-default.js")]),s._v("\n"),t("span",{staticClass:"hljs-keyword"},[s._v("export")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("default")]),s._v(" "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" ("),t("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{\n  "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),t("span",{staticClass:"hljs-string"},[s._v("'foo'")]),s._v(");\n}\n")])]),s._v(" "),t("p",[s._v("上面代码是一个模块文件export-default.js，它的默认输出是一个函数。")]),s._v(" "),t("p",[s._v("其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。")]),s._v(" "),t("pre",[t("code",{staticClass:"language-jsx"},[t("span",{staticClass:"hljs-comment"},[s._v("// import-default.js")]),s._v("\n"),t("span",{staticClass:"hljs-keyword"},[s._v("import")]),s._v(" customName "),t("span",{staticClass:"hljs-keyword"},[s._v("from")]),s._v(" "),t("span",{staticClass:"hljs-string"},[s._v("'./export-default'")]),s._v(";\ncustomName(); "),t("span",{staticClass:"hljs-comment"},[s._v("// 'foo'")]),s._v("\n")])]),s._v(" "),t("p",[s._v("上面代码的import命令，可以用任意名称指向export-default.js输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时import命令后面，不使用大括号。")]),s._v(" "),t("p",[s._v("export default命令用在非匿名函数前，也是可以的。")]),s._v(" "),t("p",[s._v("有了export default命令，输入模块时就非常直观了，以输入 lodash 模块为例。")]),s._v(" "),t("p",[s._v("import _ from 'lodash';")]),s._v(" "),t("p",[s._v("9、如下在vue中的数据方法都要用export default输出，用import引入。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ebc87f66-af47-4f39-a724-078d99be372c/Untitled.png",alt:"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ebc87f66-af47-4f39-a724-078d99be372c/Untitled.png"}})]),s._v(" "),t("p",[s._v("10、import（）不是import命令")]),s._v(" "),t("p",[s._v("import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。")]),s._v(" "),t("p",[s._v("import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。它可以（1）在函数中按需加载。（2）在if代码块中条件加载（3）动态的模块路径 import(f()) 根据函数F的返回结果，加载不同的模块；加载模块成功后，这个模块会作为一个对象，当做then方法的参数。")])])}]},n=t("VU/8")(null,v,!1,null,null,null);a.default=n.exports}});
//# sourceMappingURL=46.5fb775375174ba3e0536.js.map